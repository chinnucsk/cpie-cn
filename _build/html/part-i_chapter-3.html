
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第3章 列表编程 &mdash; Erlang并发编程</title>
    <link rel="stylesheet" href="_static/nature-ext.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Erlang并发编程" href="index.html" />
    <link rel="up" title="第 I 部分 编程" href="part-i_index.html" />
    <link rel="next" title="第4章 使用元组" href="part-i_chapter-4.html" />
    <link rel="prev" title="第2章 串行编程" href="part-i_chapter-2.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-4.html" title="第4章 使用元组"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-2.html" title="第2章 串行编程"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" accesskey="U">第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第3章 列表编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">翻译:</th><td class="field-body">连城</td>
</tr>
</tbody>
</table>
<p>这一章研究对列表的处理。列表是用于存储可变数量的元素的结构。列表的写法以“<tt class="docutils literal"><span class="pre">[</span></tt>”开头以“<tt class="docutils literal"><span class="pre">]</span></tt>”结尾。列表的元素以逗号分隔。例如，<tt class="docutils literal"><span class="pre">[E1,E2,E3,...]</span></tt>指代包含元素<tt class="docutils literal"><span class="pre">E1,E2,E3,...</span></tt>的列表。</p>
<p>标记<tt class="docutils literal"><span class="pre">[E1,E2,E3,...,En|Variable]</span></tt>，其中<tt class="docutils literal"><span class="pre">n</span></tt> ≥ <tt class="docutils literal"><span class="pre">1</span></tt>，用于表示前<tt class="docutils literal"><span class="pre">n</span></tt>个元素为<tt class="docutils literal"><span class="pre">E1,E2,E3,...,En</span></tt>其余部分由<tt class="docutils literal"><span class="pre">Variable</span></tt>指代的列表。当<tt class="docutils literal"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">1</span></tt>时，列表的形式为<tt class="docutils literal"><span class="pre">[H|T]</span></tt>；这个形式的出现频率非常高，通常将<tt class="docutils literal"><span class="pre">H</span></tt>称为列表的<strong>头部</strong>，而<tt class="docutils literal"><span class="pre">T</span></tt>为列表的<strong>尾部</strong>。</p>
<p>本章我们将讨论如何处理<strong>真</strong>列表；即尾部为空列表<tt class="docutils literal"><span class="pre">[]</span></tt>的列表。</p>
<p>应该记住在处理<strong>固定数目</strong>的元素时总是应该使用元组<tt class="docutils literal"><span class="pre">tuple</span></tt>。元组所占的存储空间仅是列表的一半并且访问也更迅速。在需要处理可变数目个元素时才应该使用列表。</p>
<div class="section" id="bif">
<h2>用于列表处理的BIF<a class="headerlink" href="#bif" title="永久链接至标题">¶</a></h2>
<p>一些内置函数可用于列表与其他数据类型间的互相转换。主要的BIF包括：</p>
<p><tt class="docutils literal"><span class="pre">atom_to_list(A)</span></tt></p>
<blockquote>
<div><p>将原子式<tt class="docutils literal"><span class="pre">A</span></tt>转换为一个ASCII字符列表。</p>
<p>如：<tt class="docutils literal"><span class="pre">atom_to_list(hello)</span></tt>⇒<tt class="docutils literal"><span class="pre">[104,101,108,108,111]</span></tt><a class="footnote-reference" href="#id13" id="id2">[1]</a>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">float_to_list(F)</span></tt></p>
<blockquote>
<div><p>将浮点数<tt class="docutils literal"><span class="pre">F</span></tt>转换为一个ASCII字符列表。</p>
<p>如：<tt class="docutils literal"><span class="pre">float_to_list(1.5)</span></tt>⇒<tt class="docutils literal"><span class="pre">[49,46,53,48,48,...,48]</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">integer_to_list(I)</span></tt></p>
<blockquote>
<div><p>将整数<tt class="docutils literal"><span class="pre">I</span></tt>转换为一个ASCII字符列表。</p>
<p>如：<tt class="docutils literal"><span class="pre">integer_to_list(1245)</span></tt>⇒<tt class="docutils literal"><span class="pre">[[49,50,52,53]</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">list_to_atom(L)</span></tt></p>
<blockquote>
<div><p>将ASCII字符列表<tt class="docutils literal"><span class="pre">L</span></tt>转换为一个原子式。</p>
<p>如：<tt class="docutils literal"><span class="pre">list_to_atom([119,111,114,108,100])</span></tt>⇒<tt class="docutils literal"><span class="pre">world</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">list_to_float(L)</span></tt></p>
<blockquote>
<div><p>将ASCII字符列表<tt class="docutils literal"><span class="pre">L</span></tt>转换为一个浮点数。</p>
<p>如：<tt class="docutils literal"><span class="pre">list_to_float([51,46,49,52,49,53,57])</span></tt>⇒<tt class="docutils literal"><span class="pre">3.14159</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">list_to_integer(L)</span></tt></p>
<blockquote>
<div><p>将ASCII字符列表<tt class="docutils literal"><span class="pre">L</span></tt>转换为一个整数。</p>
<p>如：<tt class="docutils literal"><span class="pre">list_to_integer([49,50,51,52])</span></tt>⇒<tt class="docutils literal"><span class="pre">1234</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">hd(L)</span></tt></p>
<blockquote>
<div><p>返回列表<tt class="docutils literal"><span class="pre">L</span></tt>的第一个元素。</p>
<p>如：<tt class="docutils literal"><span class="pre">hd([a,b,c,d])</span></tt>⇒<tt class="docutils literal"><span class="pre">a</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">tl(L)</span></tt></p>
<blockquote>
<div><p>返回列表<tt class="docutils literal"><span class="pre">L</span></tt>的尾部。</p>
<p>如：<tt class="docutils literal"><span class="pre">tl([a,b,c,d])</span></tt>⇒<tt class="docutils literal"><span class="pre">[b,c,d]</span></tt>。</p>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">length(L)</span></tt></p>
<blockquote>
<div><p>返回列表<tt class="docutils literal"><span class="pre">L</span></tt>的长度。</p>
<p>如：<tt class="docutils literal"><span class="pre">length([a,b,c,d])</span></tt>⇒<tt class="docutils literal"><span class="pre">4</span></tt>。</p>
</div></blockquote>
<p>有两个BIF <tt class="docutils literal"><span class="pre">tuple_to_list/1</span></tt>和<tt class="docutils literal"><span class="pre">list_to_tuple/1</span></tt>将放在第??章讨论。还有一些列表处理相关的BIF，如<tt class="docutils literal"><span class="pre">list_to_pid(AsciiList)</span></tt>、<tt class="docutils literal"><span class="pre">pid_to_list(Pid)</span></tt>。这些将在附录B中描述。</p>
</div>
<div class="section" id="id3">
<h2>常用列表处理函数<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>以下各小节给出了一些简单列表处理函数的使用示例。这里所描述的所有函数都包含在标准Erlang发行版的<tt class="docutils literal"><span class="pre">lists</span></tt>模块中（细节参见附录C）。</p>
<div class="section" id="member">
<h3><tt class="docutils literal"><span class="pre">member</span></tt><a class="headerlink" href="#member" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">member(X,</span> <span class="pre">L)</span></tt>在<tt class="docutils literal"><span class="pre">X</span></tt>是列表<tt class="docutils literal"><span class="pre">L</span></tt>的元素时返回<tt class="docutils literal"><span class="pre">true</span></tt>，否则返回<tt class="docutils literal"><span class="pre">false</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|_])</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">);</span>
<span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[])</span> <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">member</span></tt>的第一个子句匹配的是<tt class="docutils literal"><span class="pre">X</span></tt>为列表的第一个元素的情况，这种情况下<tt class="docutils literal"><span class="pre">member</span></tt>返回<tt class="docutils literal"><span class="pre">true</span></tt>。如果第一个子句不匹配，则第二个子句将匹配第二个参数是非空列表的情况，这种情况下模式<tt class="docutils literal"><span class="pre">[_|T]</span></tt>匹配一个非空列表并将<tt class="docutils literal"><span class="pre">T</span></tt>绑定到列表的尾部，然后以原来的<tt class="docutils literal"><span class="pre">X</span></tt>及列表的尾部<tt class="docutils literal"><span class="pre">T</span></tt>递归调用<tt class="docutils literal"><span class="pre">member</span></tt>。<tt class="docutils literal"><span class="pre">member</span></tt>前两个子句就是在说当<tt class="docutils literal"><span class="pre">X</span></tt>是列表的<strong>第一个</strong>元素（头部），或它被包含在列表的剩余部分（尾部）中时，<tt class="docutils literal"><span class="pre">X</span></tt>就是该列表的一个成员。<tt class="docutils literal"><span class="pre">member</span></tt>的第三个子句是说<tt class="docutils literal"><span class="pre">X</span></tt>不可能是空列表<tt class="docutils literal"><span class="pre">[]</span></tt>的成员，并因此返回<tt class="docutils literal"><span class="pre">false</span></tt>。</p>
<p>我们将<tt class="docutils literal"><span class="pre">member</span></tt>的求值过程列举如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]).</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="n">true</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">true</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="n">true</span>
<span class="n">true</span>
<span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]).</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)....</span><span class="nn">lists</span><span class="p">:</span><span class="n">member</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[])</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)....</span><span class="n">false</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...</span><span class="n">false</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="n">false</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">false</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="n">false</span>
<span class="n">false</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h3><tt class="docutils literal"><span class="pre">append</span></tt><a class="headerlink" href="#append" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">append(A,B)</span></tt>连接两个列表<tt class="docutils literal"><span class="pre">A</span></tt>和<tt class="docutils literal"><span class="pre">B</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">append</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">L1</span><span class="p">],</span> <span class="nv">L2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="n">append</span><span class="p">(</span><span class="nv">L1</span><span class="p">,</span> <span class="nv">L2</span><span class="p">)];</span>
<span class="nf">append</span><span class="p">([],</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">L</span><span class="p">.</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">append</span></tt>的第二个子句再明白不过了——将任意列表<tt class="docutils literal"><span class="pre">L</span></tt>追加至空列表之后仍得到<tt class="docutils literal"><span class="pre">L</span></tt>。</p>
<p>第一个子句给出了追加一个非空列表到另一个列表之后的规则。因此，对于：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])</span>
</pre></div>
</div>
<p>其求值结果为：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">[</span><span class="n">a</span> <span class="p">|</span> <span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])]</span>
</pre></div>
</div>
<p>那么<tt class="docutils literal"><span class="pre">append([b,c],</span> <span class="pre">[d,e,f])</span></tt>的值又是多少呢？它（当然）是<tt class="docutils literal"><span class="pre">[b,c,d,e,f]</span></tt>，因此<tt class="docutils literal"><span class="pre">[a</span> <span class="pre">|</span> <span class="pre">append([b,c],</span> <span class="pre">[d,e,f])]</span></tt>的值就是<tt class="docutils literal"><span class="pre">[a|append([b,c],</span> <span class="pre">[d,e,f])]</span></tt>，这也是<tt class="docutils literal"><span class="pre">[a,b,c,d,e,f]</span></tt>的另一种写法。</p>
<p><tt class="docutils literal"><span class="pre">append</span></tt>的行为如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">],[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]).</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">],[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([</span><span class="n">c</span><span class="p">],[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...</span><span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...[</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..[</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="reverse">
<h3><tt class="docutils literal"><span class="pre">reverse</span></tt><a class="headerlink" href="#reverse" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">reverse(L)</span></tt>用于颠倒列表<tt class="docutils literal"><span class="pre">L</span></tt>中的元素顺序。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">reverse</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">reverse</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">Acc</span><span class="p">]);</span>
<span class="nf">reverse</span><span class="p">([],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Acc</span><span class="p">.</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">reverse(L)</span></tt>利用一个<strong>辅助</strong>函数<tt class="docutils literal"><span class="pre">reverse/2</span></tt>将最终结果累积到第二个参数中。</p>
<p>调用<tt class="docutils literal"><span class="pre">reverse(L,</span> <span class="pre">Acc)</span></tt>时，若<tt class="docutils literal"><span class="pre">L</span></tt>是一个非空列表，则将<tt class="docutils literal"><span class="pre">L</span></tt>的第一个元素移除并<strong>添加</strong>到<tt class="docutils literal"><span class="pre">Acc</span></tt>的头部。因此对<tt class="docutils literal"><span class="pre">reverse([x,y,z],</span> <span class="pre">Acc)</span></tt>的调用将导致<tt class="docutils literal"><span class="pre">reverse([y,z],</span> <span class="pre">[x|Acc])</span></tt>的调用。最终<tt class="docutils literal"><span class="pre">reverse/2</span></tt>的第一个参数将归结为一个空列表，这时<tt class="docutils literal"><span class="pre">reverse/2</span></tt>的第二个子句将被匹配并另函数结束。</p>
<p>整个过程如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">]).</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">],</span> <span class="p">[])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)....</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([</span><span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="p">(</span><span class="mi">5</span><span class="p">).....</span><span class="nn">lists</span><span class="p">:</span><span class="n">reverse</span><span class="p">([],</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="p">(</span><span class="mi">5</span><span class="p">).....[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)....[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)...[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)..[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">(</span><span class="mi">1</span><span class="p">).[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="delete-all">
<h3><tt class="docutils literal"><span class="pre">delete_all</span></tt><a class="headerlink" href="#delete-all" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">delete_all(X,</span> <span class="pre">L)</span></tt>用于删除列表<tt class="docutils literal"><span class="pre">L</span></tt>中出现的所有<tt class="docutils literal"><span class="pre">X</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">delete_all</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="n">delete_all</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">);</span>
<span class="nf">delete_all</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">Y</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">Y</span> <span class="p">|</span> <span class="n">delete_all</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">T</span><span class="p">)];</span>
<span class="nf">delete_all</span><span class="p">(_,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">delete_all</span></tt>所使用的递归模式与<tt class="docutils literal"><span class="pre">member</span></tt>和<tt class="docutils literal"><span class="pre">append</span></tt>类似。</p>
<p><tt class="docutils literal"><span class="pre">delete_all</span></tt>的第一个子句在要删除的元素出现在列表的头部时匹配。</p>
</div>
</div>
<div class="section" id="id4">
<h2>示例<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>在以下章节中我们将给出一些稍微复杂一些的列表处理函数的使用示例。</p>
<div class="section" id="sort">
<h3><tt class="docutils literal"><span class="pre">sort</span></tt><a class="headerlink" href="#sort" title="永久链接至标题">¶</a></h3>
<p>程序3.1是著名的快速排序的一个变体。<tt class="docutils literal"><span class="pre">sort(X)</span></tt>对列表<tt class="docutils literal"><span class="pre">X</span></tt>的元素排序，将结果放入一个新列表并将之返回。</p>
<div class="topic">
<p class="topic-title first">程序3.1</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">sort</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">sort</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">sort</span><span class="p">([])</span> <span class="o">-&gt;</span> <span class="p">[];</span>
<span class="nf">sort</span><span class="p">([</span><span class="nv">Pivot</span><span class="p">|</span><span class="nv">Rest</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="nv">Smaller</span><span class="p">,</span> <span class="nv">Bigger</span><span class="p">}</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">),</span>
    <span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="nv">Smaller</span><span class="p">),</span> <span class="p">[</span><span class="nv">Pivot</span><span class="p">|</span><span class="n">sort</span><span class="p">(</span><span class="nv">Bigger</span><span class="p">)]).</span>

<span class="nf">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">L</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]).</span>

<span class="nf">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[],</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">Bigger</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="nv">Smaller</span><span class="p">,</span><span class="nv">Bigger</span><span class="p">};</span>
<span class="nf">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">Bigger</span><span class="p">)</span> <span class="k">when</span> <span class="nv">H</span> <span class="o">&lt;</span> <span class="nv">Pivot</span> <span class="o">-&gt;</span>
    <span class="n">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">Smaller</span><span class="p">],</span> <span class="nv">Bigger</span><span class="p">);</span>
<span class="nf">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="nv">Bigger</span><span class="p">)</span> <span class="k">when</span> <span class="nv">H</span> <span class="o">&gt;=</span> <span class="nv">Pivot</span> <span class="o">-&gt;</span>
    <span class="n">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">T</span><span class="p">,</span> <span class="nv">Smaller</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">Bigger</span><span class="p">]).</span>
</pre></div>
</div>
</div>
<p>此处选取列表的第一个元素为中轴。元列表被分为两个列表<tt class="docutils literal"><span class="pre">Smaller</span></tt>和<tt class="docutils literal"><span class="pre">Bigger</span></tt>：<tt class="docutils literal"><span class="pre">Smaller</span></tt>的所有元素都小于中轴<tt class="docutils literal"><span class="pre">Pivot</span></tt>而<tt class="docutils literal"><span class="pre">Bigger</span></tt>的所有元素都大于等于<tt class="docutils literal"><span class="pre">Pivot</span></tt>。之后，再对列表<tt class="docutils literal"><span class="pre">Smaller</span></tt>和<tt class="docutils literal"><span class="pre">Bigger</span></tt>分别排序并将结果合并。</p>
<p>函数<tt class="docutils literal"><span class="pre">split({Pivot,</span> <span class="pre">L})</span></tt>返回元组<tt class="docutils literal"><span class="pre">{Smaller,</span> <span class="pre">Bigger}</span></tt>，其中所有<tt class="docutils literal"><span class="pre">Bigger</span></tt>中的元素都大于等于<tt class="docutils literal"><span class="pre">Pivot</span></tt>而所有<tt class="docutils literal"><span class="pre">Smaller</span></tt>中的元素都小于<tt class="docutils literal"><span class="pre">Pivot</span></tt>。<tt class="docutils literal"><span class="pre">split(Pivot,</span> <span class="pre">L)</span></tt>通过调用一个辅助函数<tt class="docutils literal"><span class="pre">split(Pivot,</span> <span class="pre">L,</span> <span class="pre">Smaller,</span> <span class="pre">Bigger)</span></tt>完成任务。两个累加列表，<tt class="docutils literal"><span class="pre">Smaller</span></tt>和<tt class="docutils literal"><span class="pre">Bigger</span></tt>分别用于存储<tt class="docutils literal"><span class="pre">L</span></tt>中小于和大于等于<tt class="docutils literal"><span class="pre">Pivot</span></tt>的元素。<tt class="docutils literal"><span class="pre">split/4</span></tt>的代码与<tt class="docutils literal"><span class="pre">reverse/2</span></tt>非常相像，只是多用了一个累加列表。例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">split</span><span class="p">(</span><span class="mi">7</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]).</span>
<span class="p">{[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">23</span><span class="p">]}</span>
</pre></div>
</div>
<p>如果我们调用<tt class="docutils literal"><span class="pre">sort([7,2,1,4,23,6,8,43,9,3])</span></tt>，首先就会以<tt class="docutils literal"><span class="pre">7</span></tt>为中轴来调用<tt class="docutils literal"><span class="pre">split/2</span></tt>。这将产生两个列表：所有元素都小于中轴<tt class="docutils literal"><span class="pre">7</span></tt>的<tt class="docutils literal"><span class="pre">[3,6,4,1,2]</span></tt>，以及所有元素都大于等于中轴的<tt class="docutils literal"><span class="pre">[9,43,8,23]</span></tt>。</p>
<p>假设<tt class="docutils literal"><span class="pre">sort</span></tt>工作正常，则<tt class="docutils literal"><span class="pre">sort([3,6,4,1,2])</span></tt>⇒<tt class="docutils literal"><span class="pre">[1,2,3,4,6]</span></tt>而<tt class="docutils literal"><span class="pre">sort([9,43,8,23])</span></tt>⇒<tt class="docutils literal"><span class="pre">[8,9,23,43]</span></tt>。最后，排好序的列表被拼装在一起：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span> <span class="p">|</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">43</span><span class="p">]]).</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">43</span><span class="p">]</span>
</pre></div>
</div>
<p>再动一点脑筋，都<tt class="docutils literal"><span class="pre">append</span></tt>的调用也可以省掉，如下所示：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">qsort</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">qsort</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[]).</span>

<span class="c">%% qsort(A,B)</span>
<span class="c">%%   Inputs:</span>
<span class="c">%%      A = unsorted List</span>
<span class="c">%%      B = sorted list where all elements in B</span>
<span class="c">%%          are greater than any element in A</span>
<span class="c">%%   Returns</span>
<span class="c">%%      sort(A) appended to B</span>

<span class="nf">qsort</span><span class="p">([</span><span class="nv">Pivot</span><span class="p">|</span><span class="nv">Rest</span><span class="p">],</span> <span class="nv">Tail</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="nv">Smaller</span><span class="p">,</span><span class="nv">Bigger</span><span class="p">}</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="nv">Pivot</span><span class="p">,</span> <span class="nv">Rest</span><span class="p">),</span>
    <span class="n">qsort</span><span class="p">(</span><span class="nv">Smaller</span><span class="p">,</span> <span class="p">[</span><span class="nv">Pivot</span><span class="p">|</span><span class="n">qsort</span><span class="p">(</span><span class="nv">Bigger</span><span class="p">,</span><span class="nv">Tail</span><span class="p">)]);</span>
<span class="nf">qsort</span><span class="p">([],</span> <span class="nv">Tail</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Tail</span><span class="p">.</span>
</pre></div>
</div>
<p>我们可以利用BIF<tt class="docutils literal"><span class="pre">statistics/1</span></tt>（用于提供系统性能相关的信息，参见附录??）将之与第一版的<tt class="docutils literal"><span class="pre">sort</span></tt>做一个对比。如果我们编译并执行以下代码片段：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">...</span>
<span class="nb">statistics</span><span class="p">(</span><span class="n">reductions</span><span class="p">),</span>
<span class="nn">lists</span><span class="p">:</span><span class="n">sort</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]),</span>
<span class="p">{_,</span> <span class="nv">Reductions1</span><span class="p">}</span> <span class="o">=</span> <span class="nb">statistics</span><span class="p">(</span><span class="n">reductions</span><span class="p">),</span>
<span class="nn">lists</span><span class="p">:</span><span class="n">qsort</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]),</span>
<span class="p">{_,</span> <span class="nv">Reductions2</span><span class="p">}</span> <span class="o">=</span> <span class="nb">statistics</span><span class="p">(</span><span class="n">reductions</span><span class="p">),</span>
<span class="p">...</span>
</pre></div>
</div>
<p>我们可以得知<tt class="docutils literal"><span class="pre">sort</span></tt>和<tt class="docutils literal"><span class="pre">qsort</span></tt>的归约（函数调用）次数。在我们的示例中<tt class="docutils literal"><span class="pre">sort</span></tt>花费<tt class="docutils literal"><span class="pre">93</span></tt>次归约，而<tt class="docutils literal"><span class="pre">qsort</span></tt>花费<tt class="docutils literal"><span class="pre">74</span></tt>次，提升了百分之二十。</p>
</div>
<div class="section" id="id5">
<h3>集合<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>程序3.2是一组简单的集合操作函数。在Erlang中表示集合的最直白的方法就是采用一个不包含重复元素的无序列表。</p>
<p>集合操作函数如下：</p>
<p><tt class="docutils literal"><span class="pre">new()</span></tt></p>
<blockquote>
<div>返回一个空集合。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">add_element(X,</span> <span class="pre">S)</span></tt></p>
<blockquote>
<div>返回将元素<tt class="docutils literal"><span class="pre">X</span></tt>并入集合<tt class="docutils literal"><span class="pre">S</span></tt> 产生的新集合。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">del_element(X,</span> <span class="pre">S)</span></tt></p>
<blockquote>
<div>返回从集合<tt class="docutils literal"><span class="pre">S</span></tt>中删去元素<tt class="docutils literal"><span class="pre">X</span></tt>的新集合。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">is_element(X,</span> <span class="pre">S)</span></tt></p>
<blockquote>
<div>当元素<tt class="docutils literal"><span class="pre">X</span></tt>在集合<tt class="docutils literal"><span class="pre">S</span></tt>中时返回<tt class="docutils literal"><span class="pre">true</span></tt>，否则返回<tt class="docutils literal"><span class="pre">false</span></tt>。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">is_empty(S)</span></tt></p>
<blockquote>
<div>当集合<tt class="docutils literal"><span class="pre">S</span></tt>为空集时返回<tt class="docutils literal"><span class="pre">true</span></tt>，否则返回<tt class="docutils literal"><span class="pre">false</span></tt>。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">union(S1,</span> <span class="pre">S2)</span></tt></p>
<blockquote>
<div>返回集合<tt class="docutils literal"><span class="pre">S1</span></tt>和<tt class="docutils literal"><span class="pre">S2</span></tt>的并集，即包含了<tt class="docutils literal"><span class="pre">S1</span></tt>或<tt class="docutils literal"><span class="pre">S2</span></tt>所有元素的集合。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">intersection(S1,</span> <span class="pre">S2)</span></tt></p>
<blockquote>
<div>返回集合<tt class="docutils literal"><span class="pre">S1</span></tt>和<tt class="docutils literal"><span class="pre">S2</span></tt>的交集，即仅包含既包含于<tt class="docutils literal"><span class="pre">S1</span></tt>又包含于<tt class="docutils literal"><span class="pre">S2</span></tt>的元素的集合。</div></blockquote>
<p>严格地说，我们并不能说<tt class="docutils literal"><span class="pre">new</span></tt>返回了一个空集，而应该说<tt class="docutils literal"><span class="pre">new</span></tt>返回了一个空集的<strong>表示</strong>。如果我们将集合表示为列表，则以上的集合操作可以编写如下：</p>
<div class="topic">
<p class="topic-title first">程序3.2</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">sets</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">new</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="n">add_element</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">del_element</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">is_element</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">is_empty</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="n">union</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">intersection</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="nf">new</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[].</span>

<span class="nf">add_element</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Set</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">is_element</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Set</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">Set</span><span class="p">;</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="nv">Set</span><span class="p">]</span>
    <span class="k">end</span><span class="p">.</span>

<span class="nf">del_element</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">X</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nv">T</span><span class="p">;</span>
<span class="nf">del_element</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[</span><span class="nv">Y</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nv">Y</span><span class="p">|</span><span class="n">del_element</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span><span class="nv">T</span><span class="p">)];</span>
<span class="nf">del_element</span><span class="p">(_,</span> <span class="p">[])</span>    <span class="o">-&gt;</span> <span class="p">[].</span>

<span class="nf">is_element</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|_])</span>   <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="nf">is_element</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">Set</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">is_element</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="nv">Set</span><span class="p">);</span>
<span class="nf">is_element</span><span class="p">(_,</span> <span class="p">[])</span>      <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>

<span class="nf">is_empty</span><span class="p">([])</span> <span class="o">-&gt;</span> <span class="n">true</span><span class="p">;</span>
<span class="nf">is_empty</span><span class="p">(_)</span>  <span class="o">-&gt;</span> <span class="n">false</span><span class="p">.</span>

<span class="nf">union</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">union</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="n">add_element</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="nv">Set</span><span class="p">));</span>
<span class="nf">union</span><span class="p">([],</span> <span class="nv">Set</span><span class="p">)</span>    <span class="o">-&gt;</span> <span class="nv">Set</span><span class="p">.</span>

<span class="nf">intersection</span><span class="p">(</span><span class="nv">S1</span><span class="p">,</span> <span class="nv">S2</span><span class="p">)</span>       <span class="o">-&gt;</span> <span class="n">intersection</span><span class="p">(</span><span class="nv">S1</span><span class="p">,</span> <span class="nv">S2</span><span class="p">,</span> <span class="p">[]).</span>
<span class="nf">intersection</span><span class="p">([],</span> <span class="p">_,</span> <span class="nv">S</span><span class="p">)</span>     <span class="o">-&gt;</span> <span class="nv">S</span><span class="p">;</span>
<span class="nf">intersection</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">S1</span><span class="p">,</span> <span class="nv">S</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">is_element</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span><span class="nv">S1</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="n">intersection</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">S1</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">S</span><span class="p">]);</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="n">intersection</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">S1</span><span class="p">,</span> <span class="nv">S</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>运行程序3.2的代码：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nv">S1</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">new</span><span class="p">().</span>
<span class="p">[]</span>
<span class="o">&gt;</span> <span class="nv">S2</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">add_element</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nv">S1</span><span class="p">).</span>
<span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nv">S3</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">add_element</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nv">S2</span><span class="p">).</span>
<span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nn">sets</span><span class="p">:</span><span class="n">is_element</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nv">S3</span><span class="p">).</span>
<span class="n">true</span>
<span class="o">&gt;</span> <span class="nn">sets</span><span class="p">:</span><span class="n">is_element</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">S2</span><span class="p">).</span>
<span class="n">false</span>
<span class="o">&gt;</span> <span class="nv">T1</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">new</span><span class="p">().</span>
<span class="p">[]</span>
<span class="o">&gt;</span> <span class="nv">T2</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">add_element</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nv">T1</span><span class="p">).</span>
<span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nv">T3</span> <span class="o">=</span> <span class="nn">sets</span><span class="p">:</span><span class="n">add_element</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nv">T2</span><span class="p">).</span>
<span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nn">sets</span><span class="p">:</span><span class="n">intersection</span><span class="p">(</span><span class="nv">S3</span><span class="p">,</span> <span class="nv">T3</span><span class="p">).</span>
<span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="mi">10</span><span class="o">&gt;</span> <span class="nn">sets</span><span class="p">:</span><span class="n">union</span><span class="p">(</span><span class="nv">S3</span><span class="p">,</span><span class="nv">T3</span><span class="p">).</span>
<span class="p">[</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>这个实现并不十分高效，但足够简单以保证其正确性（但愿如此）。今后还可以将之替换为一套更高效的实现。</p>
</div>
<div class="section" id="id6">
<h3>素数<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>在我们的最后一个例子（程序3.3）中，我们将来看看如何使用<strong>埃拉托色尼筛法</strong>来生成一张素数表。</p>
<div class="topic">
<p class="topic-title first">程序 3.3</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">siv</span><span class="p">).</span>
<span class="p">-</span><span class="ni">compile</span><span class="p">(</span><span class="n">export_all</span><span class="p">).</span>

<span class="nf">range</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">N</span><span class="p">];</span>
<span class="nf">range</span><span class="p">(</span><span class="nv">Min</span><span class="p">,</span> <span class="nv">Max</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">Min</span> <span class="p">|</span> <span class="n">range</span><span class="p">(</span><span class="nv">Min</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Max</span><span class="p">)].</span>

<span class="nf">remove_multiples</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="k">when</span> <span class="nv">H</span> <span class="ow">rem</span> <span class="nv">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span>
    <span class="n">remove_multiples</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">T</span><span class="p">);</span>
<span class="nf">remove_multiples</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">H</span> <span class="p">|</span> <span class="n">remove_multiples</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">T</span><span class="p">)];</span>
<span class="nf">remove_multiples</span><span class="p">(_,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>

<span class="nf">sieve</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nv">H</span> <span class="p">|</span> <span class="n">sieve</span><span class="p">(</span><span class="n">remove_multiples</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="nv">T</span><span class="p">))];</span>
<span class="nf">sieve</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>

<span class="nf">primes</span><span class="p">(</span><span class="nv">Max</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">sieve</span><span class="p">(</span><span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nv">Max</span><span class="p">)).</span>
</pre></div>
</div>
</div>
<p>注意在程序3.3中我们使用了编译器标注<tt class="docutils literal"><span class="pre">-compile(export_all)</span></tt>——这将隐式地导出该模块中的所有函数，于是我们无须显式地给出导出申明便可以调用这些函数。</p>
<p><tt class="docutils literal"><span class="pre">range(Min,</span> <span class="pre">Max)</span></tt>返回一个包含从<tt class="docutils literal"><span class="pre">Min</span></tt>到<tt class="docutils literal"><span class="pre">Max</span></tt>的所有整数的列表。</p>
<p><tt class="docutils literal"><span class="pre">remove_multiples(N,</span> <span class="pre">L)</span></tt>从列表<tt class="docutils literal"><span class="pre">L</span></tt>删除中<tt class="docutils literal"><span class="pre">N</span></tt>的倍数：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">siv</span><span class="p">:</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">).</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nn">siv</span><span class="p">:</span><span class="n">remove_multiples</span><span class="p">(</span><span class="mi">3</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]).</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">sieve(L)</span></tt>保留列表<tt class="docutils literal"><span class="pre">L</span></tt>的头部，对于尾部的列表，则再递归地删除其头部的所有倍数：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">siv</span><span class="p">:</span><span class="n">primes</span><span class="p">(</span><span class="mi">25</span><span class="p">).</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">23</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>列表的常用递归模式<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>尽管一个典型的程序往往会使用很多不同的函数来操作列表，但大多数列表处理函数都是由少数几种模式演变而来。大部分列表处理函数无非就是在干着这些事情：</p>
<ul class="simple">
<li>在一个列表中寻找一个元素，并在找到时做些事情。</li>
<li>对输入列表的每个元素做些事情并构造一个与其结构相同的输出列表。</li>
<li>在遇到列表中的第<em>n</em>个元素时做些事情。</li>
<li>对列表进行扫描，并构造一个或一组与原列表相关的新列表。</li>
</ul>
<p>我们将以此对其进行讨论。</p>
<div class="section" id="id8">
<h3>搜索列表元素<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<p>给定以下递归模式：</p>
<div class="highlight-erlang"><pre>search(X, [X|T]) -&gt;
    ... do something ...
    ...;
search(X, [_|T]) -&gt;
    search(X, T);
search(X, []) -&gt;
    ... didn't find it ...</pre>
</div>
<p>第一种情况匹配的是找到了我们所感兴趣的项的情形。第二种情况在列表的头部不是我们所感兴趣的项时匹配，这时将接着处理列表的尾部。最后一种情况匹配的是列表元素耗尽的情形。</p>
<p>将以上代码与<tt class="docutils literal"><span class="pre">member/2</span></tt>的代码（第??节）作个比较，我们可以看到我们不过是把<tt class="docutils literal"><span class="pre">...</span> <span class="pre">do</span> <span class="pre">something</span> <span class="pre">...</span></tt>换成了<tt class="docutils literal"><span class="pre">true</span></tt>，把<tt class="docutils literal"><span class="pre">...</span> <span class="pre">didn't</span> <span class="pre">find</span> <span class="pre">it</span> <span class="pre">...</span></tt>换成了<tt class="docutils literal"><span class="pre">false</span></tt>。</p>
</div>
<div class="section" id="id9">
<h3>构建同构列表<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<p>有时我们会想构造一个<strong>形如</strong>输入列表的列表，但同时又要对输入列表的每个元素做些操作。这时可以这么写：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">isomorphic</span><span class="p">([</span><span class="nv">X</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="n">something</span><span class="p">(</span><span class="nv">X</span><span class="p">)|</span><span class="n">isomorphic</span><span class="p">(</span><span class="nv">T</span><span class="p">)];</span>
<span class="nf">isomorphic</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</pre></div>
</div>
<p>然后，比如我们想写一个将给定列表中的所有元素翻倍的函数，我们就可以这么写：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">double</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="nv">H</span> <span class="p">|</span> <span class="n">double</span><span class="p">(</span><span class="nv">T</span><span class="p">)];</span>
<span class="nf">double</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</pre></div>
</div>
<p>于是便有：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists1</span><span class="p">:</span><span class="n">double</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">]).</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
</pre></div>
</div>
<p>事实上这种手法只能作用于列表的<strong>最上层</strong>，因此如果我们想遍历列表的所有层次，我们就得将函数定义修改如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">double</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="k">when</span> <span class="n">integer</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span><span class="o">-&gt;</span>
    <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="nv">H</span> <span class="p">|</span> <span class="n">double</span><span class="p">(</span><span class="nv">T</span><span class="p">)];</span>
<span class="nf">double</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="k">when</span> <span class="n">list</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="n">double</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span> <span class="p">|</span> <span class="n">double</span><span class="p">(</span><span class="nv">T</span><span class="p">)];</span>
<span class="nf">double</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</pre></div>
</div>
<p>后一个版本就可以成功遍历深层的嵌套列表了：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists1</span><span class="p">:</span><span class="n">double</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">],</span><span class="mi">3</span><span class="p">]]).</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">10</span><span class="p">,[</span><span class="mi">12</span><span class="p">,</span><span class="mi">24</span><span class="p">],</span><span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>计数<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>我们常常要使用到计数器，以便对一个列表的第<em>n</em>个元素做些动作：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">count</span><span class="p">(</span><span class="nv">Terminal</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">...</span> <span class="n">do</span> <span class="n">something</span> <span class="p">...;</span>
<span class="nf">count</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">L</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="n">count</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
<p>则返回列表中第<em>n</em>个元素（假设其存在）的函数可以写成：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">nth</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="nv">H</span><span class="p">;</span>
<span class="nf">nth</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="n">nth</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>这种递减至一个终止条件的计数方式往往要由于递增计数。为了说明这一点，考虑同样是返回第<em>n</em>个元素但是采用递增计数的函数<tt class="docutils literal"><span class="pre">nth1</span></tt>：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">nth1</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">nth1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nv">N</span><span class="p">,</span> <span class="nv">L</span><span class="p">).</span>
<span class="nf">nth1</span><span class="p">(</span><span class="nv">Max</span><span class="p">,</span> <span class="nv">Max</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|_])</span> <span class="o">-&gt;</span>
    <span class="nv">H</span><span class="p">;</span>
<span class="nf">nth1</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Max</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="n">nth1</span><span class="p">(</span><span class="nv">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Max</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
<p>这种做法需要一个额外的参数和一个辅助函数。</p>
</div>
<div class="section" id="id11">
<h3>收集列表元素<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>现在我们希望对一个列表中的元素做些动作，生成一个或一组新的列表。对应的模式如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">collect</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">collect</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">collect</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Accumulator</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">pred</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span>
            <span class="n">collect</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="n">dosomething</span><span class="p">(</span><span class="nv">H</span><span class="p">)|</span><span class="nv">Accumulator</span><span class="p">]);</span>
        <span class="n">false</span> <span class="o">-&gt;</span>
            <span class="n">collect</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">Accumulator</span><span class="p">)</span>
    <span class="k">end</span><span class="p">;</span>
<span class="nf">collect</span><span class="p">([],</span> <span class="nv">Accumulator</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Accumulator</span><span class="p">.</span>
</pre></div>
</div>
<p>在这里我们引入了一个多出一个参数的辅助函数，多出的这个参数用于存储最终要被返回给调用方的列表。</p>
<p>借助这样一种模式，举个例子，我们可以写这样的一个函数：计算输入列表的所有偶元素的平方并删除所有奇元素：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">funny</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">funny</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">funny</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Accumulator</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">even</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="n">funny</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="o">*</span><span class="nv">H</span><span class="p">|</span><span class="nv">Accumulator</span><span class="p">]);</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="n">funny</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">Accumulator</span><span class="p">)</span>
    <span class="k">end</span><span class="p">;</span>
<span class="nf">funny</span><span class="p">([],</span> <span class="nv">Accumulator</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Accumulator</span><span class="p">.</span>
</pre></div>
</div>
<p>于是有：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">funny</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="p">[</span><span class="mi">36</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>注意在这种情况下结果列表中的元素的顺序与原列表中对应元素的顺序是相反的。</p>
<p>在递归过程中使用累加列表来构造结果经常是一种推荐的做法。这样可以编写出运行时只适用常数空间的<strong>扁平</strong>的代码（细节参见第??节）。</p>
</div>
</div>
<div class="section" id="id12">
<h2>函数式参数<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>将函数名作为参数传递给另一个函数是一种很有用的抽象特定函数行为的方法。本节将给出两个使用这种编程技术的示例。</p>
<div class="section" id="map">
<h3>map<a class="headerlink" href="#map" title="永久链接至标题">¶</a></h3>
<p>函数<tt class="docutils literal"><span class="pre">map(Func,</span> <span class="pre">List)</span></tt>返回一个列表<tt class="docutils literal"><span class="pre">L</span></tt>，其中的元素由函数<tt class="docutils literal"><span class="pre">Func</span></tt>依次作用于列表<tt class="docutils literal"><span class="pre">List</span></tt>的各个元素得到。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">map</span><span class="p">(</span><span class="nv">Func</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="nb">apply</span><span class="p">(</span><span class="nv">F</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">])|</span><span class="n">map</span><span class="p">(</span><span class="nv">Func</span><span class="p">,</span> <span class="nv">T</span><span class="p">)];</span>
<span class="nf">map</span><span class="p">(</span><span class="nv">Func</span><span class="p">,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>

<span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">map</span><span class="p">({</span><span class="n">math</span><span class="p">,</span><span class="n">factorial</span><span class="p">},</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]).</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">120</span><span class="p">,</span><span class="mi">720</span><span class="p">,</span><span class="mi">5040</span><span class="p">,</span><span class="mi">40320</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="filter">
<h3>filter<a class="headerlink" href="#filter" title="永久链接至标题">¶</a></h3>
<p>函数<tt class="docutils literal"><span class="pre">filter(Pred,</span> <span class="pre">List)</span></tt>对列表<tt class="docutils literal"><span class="pre">List</span></tt>中的元素进行过滤，仅保留令<tt class="docutils literal"><span class="pre">Pred</span></tt>的值为<tt class="docutils literal"><span class="pre">true</span></tt>的元素。这里的<tt class="docutils literal"><span class="pre">Pred</span></tt>是一个返回<tt class="docutils literal"><span class="pre">true</span></tt>或<tt class="docutils literal"><span class="pre">false</span></tt>的函数。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">filter</span><span class="p">(</span><span class="nv">Pred</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nb">apply</span><span class="p">(</span><span class="nv">Pred</span><span class="p">,[</span><span class="nv">H</span><span class="p">])</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span>
        <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="n">filter</span><span class="p">(</span><span class="nv">Pred</span><span class="p">,</span> <span class="nv">T</span><span class="p">)];</span>
    <span class="n">false</span> <span class="o">-&gt;</span>
        <span class="n">filter</span><span class="p">(</span><span class="nv">Pred</span><span class="p">,</span> <span class="nv">T</span><span class="p">)</span>
    <span class="k">end</span><span class="p">;</span>
<span class="nf">filter</span><span class="p">(</span><span class="nv">Pred</span><span class="p">,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="p">[].</span>
</pre></div>
</div>
<p>假设函数<tt class="docutils literal"><span class="pre">math:even/1</span></tt>在参数为偶数时返回<tt class="docutils literal"><span class="pre">true</span></tt>，否则返回<tt class="docutils literal"><span class="pre">fale</span></tt>，则：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">filter</span><span class="p">({</span><span class="n">math</span><span class="p">,</span><span class="n">even</span><span class="p">},</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]).</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>标记<tt class="docutils literal"><span class="pre">Lhs</span></tt>⇒<tt class="docutils literal"><span class="pre">Rhs</span></tt>代表对<tt class="docutils literal"><span class="pre">Lhs</span></tt>求值的结果为<tt class="docutils literal"><span class="pre">Rhs</span></tt>。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">第3章 列表编程</a><ul>
<li><a class="reference internal" href="#bif">用于列表处理的BIF</a></li>
<li><a class="reference internal" href="#id3">常用列表处理函数</a><ul>
<li><a class="reference internal" href="#member"><tt class="docutils literal"><span class="pre">member</span></tt></a></li>
<li><a class="reference internal" href="#append"><tt class="docutils literal"><span class="pre">append</span></tt></a></li>
<li><a class="reference internal" href="#reverse"><tt class="docutils literal"><span class="pre">reverse</span></tt></a></li>
<li><a class="reference internal" href="#delete-all"><tt class="docutils literal"><span class="pre">delete_all</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">示例</a><ul>
<li><a class="reference internal" href="#sort"><tt class="docutils literal"><span class="pre">sort</span></tt></a></li>
<li><a class="reference internal" href="#id5">集合</a></li>
<li><a class="reference internal" href="#id6">素数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7">列表的常用递归模式</a><ul>
<li><a class="reference internal" href="#id8">搜索列表元素</a></li>
<li><a class="reference internal" href="#id9">构建同构列表</a></li>
<li><a class="reference internal" href="#id10">计数</a></li>
<li><a class="reference internal" href="#id11">收集列表元素</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">函数式参数</a><ul>
<li><a class="reference internal" href="#map">map</a></li>
<li><a class="reference internal" href="#filter">filter</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="part-i_chapter-2.html"
                        title="上一章">第2章 串行编程</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="part-i_chapter-4.html"
                        title="下一章">第4章 使用元组</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-4.html" title="第4章 使用元组"
             >下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-2.html" title="第2章 串行编程"
             >上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" >第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2009, CPiE-CN志愿译者团队.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>