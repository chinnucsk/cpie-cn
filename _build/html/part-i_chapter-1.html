
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第1章 Erlang教程 &mdash; Erlang并发编程</title>
    <link rel="stylesheet" href="_static/nature-ext.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Erlang并发编程" href="index.html" />
    <link rel="up" title="第 I 部分 编程" href="part-i_index.html" />
    <link rel="next" title="第2章 串行编程" href="part-i_chapter-2.html" />
    <link rel="prev" title="第 I 部分 编程" href="part-i_index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-2.html" title="第2章 串行编程"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="part-i_index.html" title="第 I 部分 编程"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" accesskey="U">第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="erlang">
<h1>第1章 Erlang教程<a class="headerlink" href="#erlang" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">翻译:</th><td class="field-body">连城</td>
</tr>
</tbody>
</table>
<div class="section" id="id1">
<h2>串行编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>程序1.1用于计算整数的阶乘：</p>
<div class="topic">
<p class="topic-title first">程序1.1</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">math1</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">factorial</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
</div>
<p>函数可以通过<em>shell</em>程序进行交互式求值。 Shell会提示输入一个表达式，并计算和输出用户输入的任意表达式，例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">math1</span><span class="p">:</span><span class="n">factorial</span><span class="p">(</span><span class="mi">6</span><span class="p">).</span>
<span class="mi">720</span>
<span class="o">&gt;</span> <span class="nn">math1</span><span class="p">:</span><span class="n">factorial</span><span class="p">(</span><span class="mi">25</span><span class="p">).</span>
<span class="mi">15511210043330985984000000</span>
</pre></div>
</div>
<p>以上的“<tt class="docutils literal"><span class="pre">&gt;</span></tt>”代表 shell 提示符，该行的其他部分是用户输入的表达式。之后的行是表达式的求值结果。</p>
<p><tt class="docutils literal"><span class="pre">factorial</span></tt> 的代码如何被编译并加载至 Erlang 系统中是一个<strong>实现相关</strong>的问题。 <a class="footnote-reference" href="#id11" id="id2">[1]</a></p>
<p>在我们的例子中，<tt class="docutils literal"><span class="pre">factorial</span></tt>函数定义了两个子句：第一个子句描述了计算<tt class="docutils literal"><span class="pre">factorial(0)</span></tt>的规则，第二个是计算<tt class="docutils literal"><span class="pre">factorial(N)</span></tt>的规则。当使用某个参数对<tt class="docutils literal"><span class="pre">factorial</span></tt>进行求值时，两个子句按照它们在模块中出现的次序被依次扫描，直到其中一个与调用相匹配。当发现一个匹配子句时，符号<tt class="docutils literal"><span class="pre">-&gt;</span></tt>右边的表达式将被求值，求值之前函数定义式中的变量将被代入右侧的表达式。</p>
<p>所有的 Erlang 函数都从属于某一特定<strong>模块</strong>。最简单的模块包含一个模块声明、<strong>导出</strong>声明，以及该模块导出的各个函数的实现代码。导出的函数可以从模块<strong>外部</strong>被调用。其他函数只能在模块内部使用。</p>
<p>程序1.2是该规则的一个示例。</p>
<div class="topic">
<p class="topic-title first">程序1.2</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">math2</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">double</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">double</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">times</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span>

<span class="nf">times</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">X</span> <span class="o">*</span> <span class="nv">N</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>函数<tt class="docutils literal"><span class="pre">double/1</span></tt>可在模块外被求值<a class="footnote-reference" href="#id12" id="id3">[2]</a>，<tt class="docutils literal"><span class="pre">times/2</span></tt>则只能在模块内部使用，如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">math2</span><span class="p">:</span><span class="n">double</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span>
<span class="mi">20</span>
<span class="o">&gt;</span> <span class="nn">math2</span><span class="p">:</span><span class="n">times</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span>
<span class="o">**</span> <span class="n">undefined</span> <span class="nn">function</span><span class="p">:</span> <span class="nn">math2</span><span class="p">:</span><span class="n">times</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span>
</pre></div>
</div>
<p>在程序1.2中<strong>模块声明</strong><tt class="docutils literal"><span class="pre">-module(math2)</span></tt>定义了该模块的名称，<strong>导出属性</strong><tt class="docutils literal"><span class="pre">-export([double/1])</span></tt>表示本模块向外部导出具备一个参数的函数<tt class="docutils literal"><span class="pre">double</span></tt>。</p>
<p>函数调用可以嵌套：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">math2</span><span class="p">:</span><span class="n">double</span><span class="p">(</span><span class="nn">math2</span><span class="p">:</span><span class="n">double</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span>
<span class="mi">8</span>
</pre></div>
</div>
<p>Erlang 中的选择是通过模式匹配完成的。程序 1.3 给出一个示例：</p>
<div class="topic">
<p class="topic-title first">程序1.3</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">math3</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">area</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">area</span><span class="p">({</span><span class="n">square</span><span class="p">,</span> <span class="nv">Side</span><span class="p">})</span> <span class="o">-&gt;</span>
    <span class="nv">Side</span> <span class="o">*</span> <span class="nv">Side</span><span class="p">;</span>
<span class="nf">area</span><span class="p">({</span><span class="n">rectangle</span><span class="p">,</span> <span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">})</span> <span class="o">-&gt;</span>
    <span class="nv">X</span> <span class="o">*</span> <span class="nv">Y</span><span class="p">;</span>
<span class="nf">area</span><span class="p">({</span><span class="n">circle</span><span class="p">,</span> <span class="nv">Radius</span><span class="p">})</span> <span class="o">-&gt;</span>
    <span class="mi">3</span><span class="p">.</span><span class="mi">14159</span> <span class="o">*</span> <span class="nv">Radius</span> <span class="o">*</span> <span class="nv">Radius</span><span class="p">;</span>
<span class="nf">area</span><span class="p">({</span><span class="n">triangle</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="nv">C</span><span class="p">})</span> <span class="o">-&gt;</span>
    <span class="nv">S</span> <span class="o">=</span> <span class="p">(</span><span class="nv">A</span> <span class="o">+</span> <span class="nv">B</span> <span class="o">+</span> <span class="nv">C</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
    <span class="nn">math</span><span class="p">:</span><span class="n">sqrt</span><span class="p">(</span><span class="nv">S</span><span class="o">*</span><span class="p">(</span><span class="nv">S</span><span class="o">-</span><span class="nv">A</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">S</span><span class="o">-</span><span class="nv">B</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nv">S</span><span class="o">-</span><span class="nv">C</span><span class="p">)).</span>
</pre></div>
</div>
</div>
<p>如我们所期望的，对<tt class="docutils literal"><span class="pre">math3:area({triangle,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5})</span></tt>得到<tt class="docutils literal"><span class="pre">6.0000</span></tt>而<tt class="docutils literal"><span class="pre">math3:area({square,</span> <span class="pre">5})</span></tt>得到 25 。程序1.3 引入了几个新概念：</p>
<blockquote>
<div><p><strong>元组</strong>——用于替代复杂数据结构。我们可以用以下 shell 会话进行演示：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nv">Thing</span> <span class="o">=</span> <span class="p">{</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}.</span>
<span class="p">{</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="nn">math3</span><span class="p">:</span><span class="n">area</span><span class="p">(</span><span class="nv">Thing</span><span class="p">).</span>
<span class="mi">20</span><span class="p">.</span><span class="mi">3332</span>
</pre></div>
</div>
<p>此处<tt class="docutils literal"><span class="pre">Thing</span></tt>被绑定到<tt class="docutils literal"><span class="pre">{triangle,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8}</span></tt>——我们将<tt class="docutils literal"><span class="pre">Thing</span></tt>称为<strong>尺寸</strong>为4的一个元组——它包含 4 个<strong>元素</strong>。第一个元素是<strong>原子式</strong><tt class="docutils literal"><span class="pre">triangle</span></tt>，其余三个元素分别是整数6、7和8。</p>
<p><strong>模式识别</strong>——用于在一个函数中进行子句选择。<tt class="docutils literal"><span class="pre">area/1</span></tt>被定义为包含4个<strong>子句</strong>。以<tt class="docutils literal"><span class="pre">math3:area({circle,</span> <span class="pre">10})</span></tt>为例， 系统会尝试在<tt class="docutils literal"><span class="pre">area/1</span></tt>定义的子句中找出一个与<tt class="docutils literal"><span class="pre">{circle,</span> <span class="pre">10}</span></tt>相符的匹配，之后将函数定义<strong>头部</strong>中出现的自由变量<tt class="docutils literal"><span class="pre">Radius</span></tt><strong>绑定</strong>到调用中提供的值（在这个例子中是10）。</p>
<p><strong>序列</strong>和<strong>临时变量</strong>——这二者是在<tt class="docutils literal"><span class="pre">area/1</span></tt>定义的最后一个子句中出现的。最后一个子句的<strong>主体</strong>是由两条以逗号分隔的语句组成的序列；序列中的语句将<strong>依次</strong>求值。函数子句的值被定义为语句序列中的<strong>最后</strong>一个语句的值。在序列中的第一个语句中，我们引入了一个临时变量<tt class="docutils literal"><span class="pre">S</span></tt>。</p>
</div></blockquote>
</div>
<div class="section" id="id4">
<h2>数据类型<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>Erlang 提供了以下数据类型：</p>
<blockquote>
<div><p><strong>常量</strong>数据类型——无法再被分割为更多原始类型的类型：</p>
<ul class="simple">
<li><strong>数值</strong>——如：123、-789、3.14159、7.8e12、-1.2e-45。数值可进一步分为<strong>整数</strong>和<strong>浮点数</strong>。</li>
<li><strong>Atom</strong>——如：<tt class="docutils literal"><span class="pre">abc</span></tt>、<tt class="docutils literal"><span class="pre">'An</span> <span class="pre">atom</span> <span class="pre">with</span> <span class="pre">spaces'</span></tt>、<tt class="docutils literal"><span class="pre">monday</span></tt>、<tt class="docutils literal"><span class="pre">green</span></tt>、<tt class="docutils literal"><span class="pre">hello_word</span></tt>。它们都只是一些命名常量。</li>
</ul>
<p><strong>复合</strong>数据类型——用于组合其他数据类型。复合数据类型分为两种：</p>
<ul class="simple">
<li><strong>元组</strong>——如：<tt class="docutils literal"><span class="pre">{a,</span> <span class="pre">12,</span> <span class="pre">b}</span></tt>、<tt class="docutils literal"><span class="pre">{}</span></tt>、<tt class="docutils literal"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3}</span></tt>、<tt class="docutils literal"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d,</span> <span class="pre">e}</span></tt>。元组用于存储固定数量的元素，并被写作以花括号包围的元素序列。元组类似于传统编程语言中的记录或结构。</li>
<li><strong>列表</strong>——如：<tt class="docutils literal"><span class="pre">[]</span></tt>、<tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">b,</span> <span class="pre">12]</span></tt>、<tt class="docutils literal"><span class="pre">[22]</span></tt>、<tt class="docutils literal"><span class="pre">[a,</span> <span class="pre">'hello</span> <span class="pre">friend']</span></tt>。列表用于存储可变数量的元素，并被写作以方括号包围的元素序列。</li>
</ul>
</div></blockquote>
<p>元组和列表的成员本身可以是任意的 Erlang 数据元素——这使得我们可以创建任意复杂的数据结构。</p>
<p>在 Erlang 中可使用<strong>变量</strong>存储各种类型的值。变量总是以大写字母开头，例如，以下代码片段：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">X</span> <span class="o">=</span> <span class="p">{</span><span class="n">book</span><span class="p">,</span> <span class="n">preface</span><span class="p">,</span> <span class="n">acknowledgements</span><span class="p">,</span> <span class="n">contents</span><span class="p">,</span>
     <span class="p">{</span><span class="n">chapters</span><span class="p">,</span> <span class="p">[</span>
        <span class="p">{</span><span class="n">chapter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">&#39;An Erlang Tutorial&#39;</span><span class="p">},</span>
        <span class="p">{</span><span class="n">chapter</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...}</span>
        <span class="p">]</span>
     <span class="p">}},</span>
</pre></div>
</div>
<p>创建了一个复杂的数据结构并将其存于变量<tt class="docutils literal"><span class="pre">X</span></tt>中。</p>
</div>
<div class="section" id="id5">
<h2>模式识别<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>模式识别被用于变量赋值和程序流程控制。Erlang是一种<strong>单性赋值</strong>语言，即一个变量一旦被赋值，就再也不可改变。</p>
<p>模式识别用于将模式与项式进行匹配。如果一个模式与项式具备相同的结构则匹配成功，并且模式中的所有变量将被绑定到项式中相应位置上出现的数据结构。</p>
<div class="section" id="id6">
<h3>函数调用中的模式识别<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>程序1.4定义了在摄氏、华氏和列式温标间进行温度转换的函数<tt class="docutils literal"><span class="pre">convert</span></tt>。<tt class="docutils literal"><span class="pre">convert</span></tt>的第一个参数是一个包含了温标和要被转换的温度值，第二个参数是目标温标。</p>
<div class="topic">
<p class="topic-title first">程序1.4</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">temp</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">convert</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="nf">convert</span><span class="p">({</span><span class="n">fahrenheit</span><span class="p">,</span> <span class="nv">Temp</span><span class="p">},</span> <span class="n">celsius</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">celsius</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="nv">Temp</span> <span class="o">-</span> <span class="mi">32</span><span class="p">)</span> <span class="o">/</span> <span class="mi">9</span><span class="p">};</span>
<span class="nf">convert</span><span class="p">({</span><span class="n">celsius</span><span class="p">,</span> <span class="nv">Temp</span><span class="p">},</span> <span class="n">fahrenheit</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">farenheit</span><span class="p">,</span> <span class="mi">32</span> <span class="o">+</span> <span class="nv">Temp</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span><span class="p">};</span>
<span class="nf">convert</span><span class="p">({</span><span class="n">reaumur</span><span class="p">,</span> <span class="nv">Temp</span><span class="p">},</span> <span class="n">celsius</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">celsius</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nv">Temp</span> <span class="o">/</span> <span class="mi">8</span><span class="p">};</span>
<span class="nf">convert</span><span class="p">({</span><span class="n">celsius</span><span class="p">,</span> <span class="nv">Temp</span><span class="p">},</span> <span class="n">reaumur</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">reaumur</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="nv">Temp</span> <span class="o">/</span> <span class="mi">10</span><span class="p">};</span>
<span class="nf">convert</span><span class="p">({</span><span class="nv">X</span><span class="p">,</span> <span class="p">_},</span> <span class="nv">Y</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">cannot</span><span class="p">,</span><span class="n">convert</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="n">to</span><span class="p">,</span><span class="nv">Y</span><span class="p">}.</span>
</pre></div>
</div>
</div>
<p>对<tt class="docutils literal"><span class="pre">convert</span></tt>进行求值时，函数调用中出现的参数（项式）与函数定义中的模式进行匹配。当找到一个匹配时，“<tt class="docutils literal"><span class="pre">-&gt;</span></tt>”右侧的代码便被求值，如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">temp</span><span class="p">:</span><span class="n">convert</span><span class="p">({</span><span class="n">fahrenheit</span><span class="p">,</span> <span class="mi">98</span><span class="p">.</span><span class="mi">6</span><span class="p">},</span> <span class="n">celsius</span><span class="p">).</span>
<span class="p">{</span><span class="n">celsius</span><span class="p">,</span><span class="mi">37</span><span class="p">.</span><span class="mi">0000</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="nn">temp</span><span class="p">:</span><span class="n">convert</span><span class="p">({</span><span class="n">reaumur</span><span class="p">,</span> <span class="mi">80</span><span class="p">},</span> <span class="n">celsius</span><span class="p">).</span>
<span class="p">{</span><span class="n">celsius</span><span class="p">,</span><span class="mi">100</span><span class="p">.</span><span class="mi">000</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="nn">temp</span><span class="p">:</span><span class="n">convert</span><span class="p">({</span><span class="n">reaumur</span><span class="p">,</span> <span class="mi">80</span><span class="p">},</span> <span class="n">fahrenheit</span><span class="p">).</span>
<span class="p">{</span><span class="n">cannot</span><span class="p">,</span><span class="n">convert</span><span class="p">,</span><span class="n">reaumur</span><span class="p">,</span><span class="n">to</span><span class="p">,</span><span class="n">fahrenheit</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>匹配原语“<tt class="docutils literal"><span class="pre">=</span></tt>”<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>表达式<tt class="docutils literal"><span class="pre">Pattern</span> <span class="pre">=</span> <span class="pre">Expression</span></tt>致使<tt class="docutils literal"><span class="pre">Expression</span></tt>被求值并尝试与\ <tt class="docutils literal"><span class="pre">Pattern</span></tt> 进行匹配。匹配过程要么成功要么失败。一旦匹配成功，则<tt class="docutils literal"><span class="pre">Pattern</span></tt>中所有的变量都被绑定，例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nv">N</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="n">banana</span><span class="p">}.</span>
<span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="n">banana</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">}</span> <span class="o">=</span> <span class="nv">N</span><span class="p">.</span>
<span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="n">banana</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="nv">A</span><span class="p">.</span>
<span class="mi">12</span>
<span class="o">&gt;</span> <span class="nv">B</span><span class="p">.</span>
<span class="n">banana</span>
</pre></div>
</div>
<p>匹配原语可用于从复杂数据结构中<tt class="docutils literal"><span class="pre">拆分</span></tt>元素。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">}</span> <span class="o">=</span> <span class="p">{[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">}}.</span>
<span class="p">{[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],{</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">}}</span>
<span class="o">&gt;</span><span class="nv">A</span><span class="p">.</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span><span class="nv">B</span><span class="p">.</span>
<span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="nv">X</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="nv">Y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,{</span><span class="n">hello</span><span class="p">,</span> <span class="n">fred</span><span class="p">},</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">].</span>
<span class="p">[</span><span class="n">a</span><span class="p">,{</span><span class="n">hello</span><span class="p">,</span><span class="n">fred</span><span class="p">},</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nv">X</span><span class="p">.</span>
<span class="p">{</span><span class="n">hello</span><span class="p">,</span><span class="n">fred</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="nv">Y</span><span class="p">.</span>
<span class="mi">1</span>
<span class="o">&gt;</span> <span class="p">{_,</span><span class="nv">L</span><span class="p">,_}</span> <span class="o">=</span> <span class="p">{</span><span class="n">fred</span><span class="p">,{</span><span class="n">likes</span><span class="p">,</span> <span class="p">[</span><span class="n">wine</span><span class="p">,</span> <span class="n">women</span><span class="p">,</span> <span class="n">song</span><span class="p">]},</span>
  <span class="p">{</span><span class="n">drinks</span><span class="p">,</span> <span class="p">[</span><span class="n">whisky</span><span class="p">,</span> <span class="n">beer</span><span class="p">]}}.</span>
<span class="p">{</span><span class="n">fred</span><span class="p">,{</span><span class="n">likes</span><span class="p">,[</span><span class="n">wine</span><span class="p">,</span><span class="n">women</span><span class="p">,</span><span class="n">song</span><span class="p">]},{</span><span class="n">drinks</span><span class="p">,[</span><span class="n">whisky</span><span class="p">,</span><span class="n">beer</span><span class="p">]}}</span>
<span class="o">&gt;</span> <span class="nv">L</span><span class="p">.</span>
<span class="p">{</span><span class="n">likes</span><span class="p">,[</span><span class="n">wine</span><span class="p">,</span><span class="n">women</span><span class="p">,</span><span class="n">song</span><span class="p">]}</span>
</pre></div>
</div>
<p>下划线（写作“<tt class="docutils literal"><span class="pre">_</span></tt>”）代表特殊的<strong>匿名</strong>变量或<strong>无所谓</strong>变量。在语法要求需要一个变量但又不关心变量的取值时，它可用作占位符。</p>
<p>如果匹配成功，定义表达式<tt class="docutils literal"><span class="pre">Lhs</span> <span class="pre">=</span> <span class="pre">Rhs</span></tt>的取值为<tt class="docutils literal"><span class="pre">Rhs</span></tt>。这使得在单一表达式中使用多重匹配成为可能，例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">}</span> <span class="o">=</span> <span class="nv">C</span> <span class="o">=</span> <span class="n">g</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span>
</pre></div>
</div>
<p>“<tt class="docutils literal"><span class="pre">=</span></tt>”是右结合操作符，因此<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">D</span></tt>被解析为<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">(B</span> <span class="pre">=</span> <span class="pre">(C</span> <span class="pre">=</span> <span class="pre">D))</span></tt>。</p>
</div>
</div>
<div class="section" id="id8">
<h2>内置函数<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>有一些操作使用Erlang编程无法完成，或无法高效完成。例如，我们无法获悉一个原子式的内部结构，或者是得到当前时间等等——这些都属于语言范畴之外。因此Erlang提供了若干<strong>内置函数</strong>（built-in function, BIF）用于完成这些操作。</p>
<p>例如函数<tt class="docutils literal"><span class="pre">atom_to_list/1</span></tt>将一个原子式转化为一个代表该原子式的（ASCII）整数列表，而函数<tt class="docutils literal"><span class="pre">date/0</span></tt>返回当前日期：<a class="footnote-reference" href="#id13" id="id9">[*]</a></p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nb">atom_to_list</span><span class="p">(</span><span class="n">abc</span><span class="p">).</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="n">date</span><span class="p">().</span>
<span class="p">{</span><span class="mi">93</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">}</span>
</pre></div>
</div>
<p>BIF的完整列表参见附录??。</p>
</div>
<div class="section" id="id10">
<h2>并发<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>Erlang是一门<strong>并发</strong>编程语言——这意味着在Erlang中可直接对并行活动（进程）进行编程，并且其并行机制是由Erlang而不是宿主操作系统提供的。</p>
<p>为了对一组并行活动进行控制，Erlang提供了多进程原语：<tt class="docutils literal"><span class="pre">spawn</span></tt>用于启动一个并行计算（称为进程）；<tt class="docutils literal"><span class="pre">send</span></tt>向一个进程发送一条消息；而<tt class="docutils literal"><span class="pre">receive</span></tt>从一个进程中接收一条消息。</p>
<p><tt class="docutils literal"><span class="pre">spawn/3</span></tt>启动一个并发进程并返回一个可用于向该进程发送消息或从该进程接收消息的标识符。</p>
<p><tt class="docutils literal"><span class="pre">Pid</span> <span class="pre">!</span> <span class="pre">Msg</span></tt>语法用于消息发送。<tt class="docutils literal"><span class="pre">Pid</span></tt>是代表一个进程的身份的表达式或常量。<tt class="docutils literal"><span class="pre">Msg</span></tt>是要向<tt class="docutils literal"><span class="pre">Pid</span></tt>发送的消息。例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">Pid</span> <span class="o">!</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span>
</pre></div>
</div>
<p>表示将消息<tt class="docutils literal"><span class="pre">{a,</span> <span class="pre">12}</span></tt>发送至以<tt class="docutils literal"><span class="pre">Pid</span></tt>为标识符的进程（Pid是<strong>进程标识符process identifier</strong>的缩写）。在发送之前，消息中的所有参数都先被求值，因此：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">foo</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">!</span> <span class="nn">math3</span><span class="p">:</span><span class="n">area</span><span class="p">({</span><span class="n">square</span><span class="p">,</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>表示对<tt class="docutils literal"><span class="pre">foo(12)</span></tt>求值（必须返回一个有效的进程标识符），并对<tt class="docutils literal"><span class="pre">math3:area({square,</span> <span class="pre">5})</span></tt>求值，然后将计算结果（即25）作为一条消息发送给进程。<tt class="docutils literal"><span class="pre">send</span></tt>原语两侧表达式的求值顺序是不确定的。</p>
<p><tt class="docutils literal"><span class="pre">receive</span></tt>原语用于接收消息。<tt class="docutils literal"><span class="pre">receive</span></tt>语法如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">receive</span>
    <span class="nv">Message1</span> <span class="o">-&gt;</span>
        <span class="p">...</span> <span class="p">;</span>
    <span class="nv">Message2</span> <span class="o">-&gt;</span>
        <span class="p">...</span> <span class="p">;</span>
        <span class="p">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>这表示尝试接收一个由<tt class="docutils literal"><span class="pre">Message1</span></tt>、<tt class="docutils literal"><span class="pre">Message2</span></tt>等模式之一描述的消息。对该原语进行求值的进程将被挂起，直至接收到一个与<tt class="docutils literal"><span class="pre">Message1</span></tt>、<tt class="docutils literal"><span class="pre">Message2</span></tt>等模式匹配的消息。一旦找到一个匹配，即对“<tt class="docutils literal"><span class="pre">-&gt;</span></tt>”右侧的代码求值。</p>
<p>接收到消息后，消息接收模式中的所有未绑定变量都被绑定。</p>
<p><tt class="docutils literal"><span class="pre">receive</span></tt>的返回值是被匹配上的接收选项所对应的语句序列的求值结果。</p>
<p>我们可以简单认为<tt class="docutils literal"><span class="pre">send</span></tt>发生一条消息而<tt class="docutils literal"><span class="pre">receive</span></tt>接收一条消息，然而更准确的描述则是<tt class="docutils literal"><span class="pre">send</span></tt>将一条消息<strong>发送至一个进程的邮箱</strong>，而<tt class="docutils literal"><span class="pre">receive</span></tt><strong>尝试从当前进程的邮箱中取出一条消息</strong>。</p>
<p><tt class="docutils literal"><span class="pre">receive</span></tt>是有选择性的，也就是说，它从等候接收进程关注的消息队列中取走第一条与消息模式相匹配的消息。如果找不到与接收模式相匹配的消息，则进程继续挂起直至下一条消息到来——未匹配的消息被保存用于后续处理。</p>
<div class="section" id="echo">
<h3>一个echo进程<a class="headerlink" href="#echo" title="永久链接至标题">¶</a></h3>
<p>作为一个并发进程的简单示例，我们创建一个<em>echo</em>进程用于原样发回它所接收到的消息。我们假设进程<tt class="docutils literal"><span class="pre">A</span></tt>向echo进程发送消息<tt class="docutils literal"><span class="pre">{A,</span> <span class="pre">Msg}</span></tt>，则echo进程向<tt class="docutils literal"><span class="pre">A</span></tt>发送一条包含<tt class="docutils literal"><span class="pre">Msg</span></tt>的新消息。如图1.1所示。</p>
<div class="figure">
<img alt="_images/1.11.png" src="_images/1.11.png" />
<p class="caption">图1.1 一个echo进程</p>
</div>
<p>在程序1.5中<tt class="docutils literal"><span class="pre">echo:start()</span></tt>创建一个返回任何发送给它的消息的简单进程。</p>
<div class="topic">
<p class="topic-title first">程序 1.5</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">echo</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="n">loop</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="nf">start</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nb">spawn</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="p">[]).</span>
<span class="nf">loop</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="nv">Message</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nv">From</span> <span class="o">!</span> <span class="nv">Message</span><span class="p">,</span>
            <span class="n">loop</span><span class="p">()</span>
    <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p><tt class="docutils literal"><span class="pre">spawn(echo,</span> <span class="pre">loop</span> <span class="pre">[])</span></tt>对<tt class="docutils literal"><span class="pre">echo:loop()</span></tt>所表示的函数相对于调用函数<strong>并行</strong>求值。因此，针对：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">...</span>
<span class="nv">Id</span> <span class="o">=</span> <span class="nn">echo</span><span class="p">:</span><span class="n">start</span><span class="p">(),</span>
<span class="nv">Id</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="n">hello</span><span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>进行求值将会启动一个并行进程并向该进程发送消息<tt class="docutils literal"><span class="pre">{self(),</span> <span class="pre">hello}</span></tt>——<tt class="docutils literal"><span class="pre">self()</span></tt>是用于获取当前进程标识符的BIF。</p>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>“实现相关”是指<strong>如何</strong>完成某个具体操作的细节是系统相关的，也不在本书的讨论范畴之内。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><tt class="docutils literal"><span class="pre">F/N</span></tt>标记表示具备<tt class="docutils literal"><span class="pre">N</span></tt>个参数的函数<tt class="docutils literal"><span class="pre">F</span></tt>。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[*]</a></td><td>译者注：在较新版本的Erlang中，该示例的输出为<tt class="docutils literal"><span class="pre">&quot;abc&quot;</span></tt>。当Erlang shell猜测出待打印的列表为字符串时，会尝试以字符串形式输出列表，参见<a class="reference external" href="http://www.erlang.org/pipermail/erlang-questions/2002-September/005624.html">此处</a>。感谢网友<a class="reference external" href="mailto:knuth&#46;fan&#37;&#52;&#48;qq&#46;com">孔雀翎</a>指出。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">第1章 Erlang教程</a><ul>
<li><a class="reference internal" href="#id1">串行编程</a></li>
<li><a class="reference internal" href="#id4">数据类型</a></li>
<li><a class="reference internal" href="#id5">模式识别</a><ul>
<li><a class="reference internal" href="#id6">函数调用中的模式识别</a></li>
<li><a class="reference internal" href="#id7">匹配原语“<tt class="docutils literal"><span class="pre">=</span></tt>”</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">内置函数</a></li>
<li><a class="reference internal" href="#id10">并发</a><ul>
<li><a class="reference internal" href="#echo">一个echo进程</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="part-i_index.html"
                        title="上一章">第 I 部分 编程</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="part-i_chapter-2.html"
                        title="下一章">第2章 串行编程</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-2.html" title="第2章 串行编程"
             >下一页</a></li>
        <li class="right" >
          <a href="part-i_index.html" title="第 I 部分 编程"
             >上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" >第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2009, CPiE-CN志愿译者团队.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>