
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第9章 杂项 &mdash; Erlang并发编程</title>
    <link rel="stylesheet" href="_static/nature-ext.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Erlang并发编程" href="index.html" />
    <link rel="up" title="第 I 部分 编程" href="part-i_index.html" />
    <link rel="next" title="附录A Erlang 语法参考" href="part-i_appendix-a.html" />
    <link rel="prev" title="第8章 编写健壮的应用程序" href="part-i_chapter-8.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_appendix-a.html" title="附录A Erlang 语法参考"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-8.html" title="第8章 编写健壮的应用程序"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" accesskey="U">第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第9章 杂项<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">翻译:</th><td class="field-body">连城</td>
</tr>
</tbody>
</table>
<p>本章包含：</p>
<ul class="simple">
<li>末尾调用优化——一种令尾递归程序得以在常数空间内执行的优化技术。</li>
<li>引用——提供确保在所有节点上都唯一的名称。</li>
<li>代码替换——在嵌入式实时系统中必须做到代码的<strong>运行时</strong>替换，即是说，系统不能停机。</li>
<li>端口——提供和外部世界通讯的机制。</li>
<li>二进制数据——用于操作无类型内存区域的内建数据类型。</li>
<li>进程字典——用于破坏性地存取进程全局数据。<a class="footnote-reference" href="#id3" id="id2">[*]</a></li>
<li>网络内核——网络内核用于协调分布式Erlang系统中的所有网络操作。</li>
<li>散列——一种将项式映射到唯一的整数用以实现高效的表查询操作的方法。</li>
<li>效率——我们将讨论如何编写高效的Erlang程序。</li>
</ul>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[*]</a></td><td>译者注：此处的“破坏性”指的是进程字典可被修改，从而破坏了Erlang函数式语法的变量不变性。</td></tr>
</tbody>
</table>
<div class="section" id="id4">
<h2>末尾调用优化<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>Erlang支持<strong>末尾调用优化</strong>，从而使得函数得以在固定大小的空间内执行。存储持久数据的主要手法是将之存储于由服务器进程操纵的结构中（典型实例参见第??节）。为了令这种手法得以正常工作，服务器必须利用末尾调用优化。</p>
<p>如果不这么做，服务器最终将会耗尽内存空间从而无法正常工作。</p>
<div class="section" id="id5">
<h3>尾递归<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>我们通过展示同一个函数的两种不同风格的写法来引入<strong>尾递归</strong>的概念，其中一种写法是尾递归的形式。考察定义如下的<tt class="docutils literal"><span class="pre">length</span></tt>函数：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nb">length</span><span class="p">([_|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="nb">length</span><span class="p">(</span><span class="nv">T</span><span class="p">);</span>
<span class="nb">length</span><span class="p">([])</span> <span class="o">-&gt;</span>
    <span class="mi">0</span><span class="p">.</span>
</pre></div>
</div>
<p>我们不妨对<tt class="docutils literal"><span class="pre">legth([a,</span> <span class="pre">b,</span> <span class="pre">c])</span></tt>求值。<tt class="docutils literal"><span class="pre">length</span></tt>的第一个子句将问题归结为对<tt class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">length([b,</span> <span class="pre">c])</span></tt>求值。不幸的是，<tt class="docutils literal"><span class="pre">+</span></tt>运算无法<strong>立即</strong>执行，而是得<strong>延迟</strong>到<tt class="docutils literal"><span class="pre">length([b,</span> <span class="pre">c])</span></tt>求值完毕为止。系统必须<strong>记住</strong>这个<tt class="docutils literal"><span class="pre">+</span></tt>运算并在后续的某个阶段（此时已知<tt class="docutils literal"><span class="pre">length([b,c])</span></tt>的值）系统<strong>回溯</strong>至该执行这个<tt class="docutils literal"><span class="pre">+</span></tt>运算时再实际执行运算。</p>
<p><strong>未决</strong>的运算被保存于局部数据区。这块区域的包含至少<tt class="docutils literal"><span class="pre">K</span> <span class="pre">*</span> <span class="pre">N</span></tt>个位置（其中<tt class="docutils literal"><span class="pre">K</span></tt>是一个常数，代表对<tt class="docutils literal"><span class="pre">length</span></tt>进行一次全新求值所需空间的大小，<tt class="docutils literal"><span class="pre">N</span></tt>是未决的运算数量）。</p>
<p>现在我们再写一个等价的求列表长度的函数，其中使用了一个累加器（参见第??节）。该函数仅占用固定大小的空间（为避免混淆，我们将之记为<tt class="docutils literal"><span class="pre">length1</span></tt>）：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">length1</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">length1</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>

<span class="nf">length1</span><span class="p">([_|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">length1</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="nv">N</span><span class="p">);</span>
<span class="nf">length1</span><span class="p">([],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">N</span><span class="p">.</span>
</pre></div>
</div>
<p>要求<tt class="docutils literal"><span class="pre">length1([a,</span> <span class="pre">b,</span> <span class="pre">c])</span></tt>，我们首先求<tt class="docutils literal"><span class="pre">length1([a,</span> <span class="pre">b,</span> <span class="pre">c],</span> <span class="pre">0)</span></tt>。再归结为<tt class="docutils literal"><span class="pre">length1([b,</span> <span class="pre">c],</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">0)</span></tt>。现在<tt class="docutils literal"><span class="pre">+</span></tt>运算可以<strong>立即</strong>执行了（因为所有<strong>参数</strong>都已知）。于是，计算<tt class="docutils literal"><span class="pre">length1([a,</span> <span class="pre">b,</span> <span class="pre">c])</span></tt>的函数求值过程为：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">length1</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="nf">length1</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([</span><span class="n">c</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([],</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">length1</span><span class="p">([],</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>
</div>
<p><strong>尾递归函数</strong>就是在递归调用前不累计任何未决运算的函数。如果函数子句中函数体的最后一个表达式是对自身的调用或者是个常数，那么它就是尾递归子句。如果一个函数的所有子句都是尾递归子句，那么它就是一个尾递归函数。</p>
<p>例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">rev</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">rev</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">rev</span><span class="p">([],</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">;</span>
<span class="nf">rev</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">rev</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">]).</span>
</pre></div>
</div>
<p>该函数就是尾递归函数，但：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">append</span><span class="p">([],</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">X</span><span class="p">;</span>
<span class="nf">append</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nv">H</span> <span class="p">|</span> <span class="n">append</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span><span class="nv">X</span><span class="p">)].</span>
</pre></div>
</div>
<p>就不是尾递归函数，因为第二个子句的最后一个表达式（<tt class="docutils literal"><span class="pre">[H</span> <span class="pre">|</span> <span class="pre">append(T,X)]</span></tt>中的<tt class="docutils literal"><span class="pre">|</span></tt>）既不是对<tt class="docutils literal"><span class="pre">append</span></tt>的调用，也不是常数。</p>
</div>
<div class="section" id="id6">
<h3>末尾调用优化<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>尾递归是更泛化的<strong>末尾调用优化</strong>（Last Call Optimisation，LCO）的一个特例。末尾调用优化可应用于任何函数子句最后一个表达式为函数调用的情况。</p>
<p>例如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">...</span>
    <span class="n">h</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>

<span class="nf">h</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">...</span>
    <span class="n">i</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>

<span class="nf">i</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>

    <span class="n">g</span><span class="p">(</span><span class="nv">X</span><span class="p">).</span>
</pre></div>
</div>
<p>上述代码定义了一组三个相互递归的函数。LCO使得对<tt class="docutils literal"><span class="pre">g(X)</span></tt>的求值可以在常数空间内完成。</p>
<p>仔细翻阅本书的所有服务程序示例代码会发现，这些程序都可以在常数空间<a class="footnote-reference" href="#id23" id="id7">[1]</a>内执行。</p>
</div>
</div>
<div class="section" id="id8">
<h2>引用<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p><strong>引用</strong>是全局唯一的对象。BIF <tt class="docutils literal"><span class="pre">make_ref()</span></tt>返回全局唯一的对象，该对象与系统中以及所有其他（可能存在的）运行着的节点中的所有对象都不相等。针对引用的唯一运算就是相等比较。</p>
<p>例如，我们可以在客户端—服务器模型中采用如下的接口函数：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">request</span><span class="p">(</span><span class="nv">Server</span><span class="p">,</span> <span class="nv">Req</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Server</span> <span class="o">!</span> <span class="p">{</span><span class="nv">R</span> <span class="o">=</span> <span class="n">make_ref</span><span class="p">(),</span> <span class="n">self</span><span class="p">(),</span> <span class="nv">Req</span><span class="p">},</span>
        <span class="k">receive</span>
            <span class="p">{</span><span class="nv">Server</span><span class="p">,</span> <span class="nv">R</span><span class="p">,</span> <span class="nv">Reply</span><span class="p">}</span> <span class="o">-&gt;</span>
                <span class="nv">Reply</span>
        <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">request(Server,</span> <span class="pre">Req)</span></tt>向名称为<tt class="docutils literal"><span class="pre">Server</span></tt>的服务器发送请求<tt class="docutils literal"><span class="pre">Req</span></tt>；请求中包含一个唯一引用<tt class="docutils literal"><span class="pre">R</span></tt>。在接收服务器返回的应答时会校验是否存在该唯一引用<tt class="docutils literal"><span class="pre">R</span></tt>。与服务器端的这种“端对端”的通讯方法可用于确认请求是否已被处理。</p>
</div>
<div class="section" id="id9">
<h2>代码替换<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h2>
<p>在嵌入式实时系统中，我们希望在不停机的情况下进行代码升级。比如我们希望在不影响服务的情况下修复某台大型交换机中的软件错误。</p>
<p>在运营过程中进行代码替换是“软”实时控制系统的普遍需求，这些系统往往运营时间很长，代码体积也很大。而在特殊处理器上运行或烧录在ROM里的硬实时系统则往往没有这种需求。</p>
<div class="section" id="id10">
<h3>代码替换实例<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<p>考察程序9.1。</p>
<p>我们首先编译并加载<tt class="docutils literal"><span class="pre">code_replace</span></tt>的代码。然后我们启动程序，并向创建出来的进程发送消息<tt class="docutils literal"><span class="pre">hello</span></tt>、<tt class="docutils literal"><span class="pre">global</span></tt>和<tt class="docutils literal"><span class="pre">process</span></tt>。</p>
<div class="topic">
<p class="topic-title first">程序9.1</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">code_replace</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">test</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="n">loop</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">test</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nb">register</span><span class="p">(</span><span class="n">global</span><span class="p">,</span> <span class="nb">spawn</span><span class="p">(</span><span class="n">code_replace</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])).</span>

<span class="nf">loop</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="nv">X</span> <span class="o">-&gt;</span>
            <span class="nn">io</span><span class="p">:</span><span class="n">format</span><span class="p">(</span><span class="n">&#39;N = ~w Vsn A received ~w~n&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nv">N</span><span class="p">,</span> <span class="nv">X</span><span class="p">])</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nn">code_replace</span><span class="p">:</span><span class="n">loop</span><span class="p">(</span><span class="nv">N</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
</div>
<p>最后我们再次编辑程序，将版本号从<tt class="docutils literal"><span class="pre">A</span></tt>改为<tt class="docutils literal"><span class="pre">B</span></tt>，重新编译、加载程序，并向进程发送消息<tt class="docutils literal"><span class="pre">hello</span></tt>。</p>
<p>会话结果如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="c">%%% start by compiling and loading the code</span>
<span class="c">%%%   (this is done by c:c)</span>
<span class="o">&gt;</span> <span class="nn">c</span><span class="p">:</span><span class="n">c</span><span class="p">(</span><span class="n">code_replace</span><span class="p">).</span>
<span class="p">...</span>
<span class="o">&gt;</span> <span class="nn">code_replace</span><span class="p">:</span><span class="n">test</span><span class="p">().</span>
<span class="n">true</span>
<span class="o">&gt;</span> <span class="n">global</span> <span class="o">!</span> <span class="n">hello</span><span class="p">.</span>
<span class="nv">N</span> <span class="o">=</span> <span class="mi">0</span> <span class="nv">Vsn</span> <span class="nv">A</span> <span class="n">received</span> <span class="n">hello</span>
<span class="n">hello</span>
<span class="o">&gt;</span> <span class="n">global</span> <span class="o">!</span> <span class="n">global</span><span class="p">.</span>
<span class="nv">N</span> <span class="o">=</span> <span class="mi">1</span> <span class="nv">Vsn</span> <span class="nv">A</span> <span class="n">received</span> <span class="n">global</span>
<span class="n">global</span>
<span class="o">&gt;</span> <span class="n">global</span> <span class="o">!</span> <span class="n">process</span><span class="p">.</span>
<span class="nv">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="nv">Vsn</span> <span class="nv">A</span> <span class="n">received</span> <span class="n">process</span>
<span class="c">%%% edit the file code_replace.erl</span>
<span class="c">%%% recompile and load</span>
<span class="o">&gt;</span> <span class="nn">c</span><span class="p">:</span><span class="n">c</span><span class="p">(</span><span class="n">code_replace</span><span class="p">).</span>
<span class="p">....</span>
<span class="o">&gt;</span> <span class="n">global</span> <span class="o">!</span> <span class="n">hello</span><span class="p">.</span>
<span class="nv">N</span> <span class="o">=</span> <span class="mi">3</span> <span class="nv">Vsn</span> <span class="nv">B</span> <span class="n">received</span> <span class="n">hello</span>
</pre></div>
</div>
<p>这里我们看到，在<tt class="docutils literal"><span class="pre">loop/1</span></tt>的执行过程中，虽然我们重新编译、加载了它的代码，但作为<tt class="docutils literal"><span class="pre">loop/1</span></tt>的参数的局部变量<tt class="docutils literal"><span class="pre">N</span></tt>的值仍被保留了下来。</p>
<p>注意服务器循环的代码是以如下形式编写的：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">xyz</span><span class="p">).</span>

<span class="nf">loop</span><span class="p">(</span><span class="nv">Arg1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">ArgN</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">...</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nn">xyz</span><span class="p">:</span><span class="n">loop</span><span class="p">(</span><span class="nv">NewArg1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">NewArgN</span><span class="p">).</span>
</pre></div>
</div>
<p>这与下面这样的写法有细微的差异：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">xyz</span><span class="p">).</span>

<span class="nf">loop</span><span class="p">(</span><span class="nv">Arg1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">ArgN</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">...</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="n">loop</span><span class="p">(</span><span class="nv">NewArg1</span><span class="p">,</span> <span class="p">...,</span> <span class="nv">NewArgN</span><span class="p">).</span>
</pre></div>
</div>
<p>第一种情况中调用<tt class="docutils literal"><span class="pre">xyz:loop(...)</span></tt>意味着总是使用模块<tt class="docutils literal"><span class="pre">xyz</span></tt>中<strong>最新</strong>的<tt class="docutils literal"><span class="pre">loop</span></tt>版本。第二种情况中（不显式指定模块名）则只调用<strong>当前执行模块</strong>中的<tt class="docutils literal"><span class="pre">loop</span></tt>版本。</p>
<p>显式使用模块限定名（<tt class="docutils literal"><span class="pre">module:func</span></tt>）使得<tt class="docutils literal"><span class="pre">module:func</span></tt><strong>动态</strong>链接至运行时代码。对于使用完整模块限定名的调用，系统<strong>每次</strong>都会使用最新版本的可用代码进行函数求值。模块中本地函数的地址解析在编译期完成——它们是<strong>静态</strong>的，不能在运行时改变。</p>
<p>上述会话示例中<tt class="docutils literal"><span class="pre">c:c(File)</span></tt>编译并加载<tt class="docutils literal"><span class="pre">File</span></tt>中的代码。在第??节对此有详细讨论。</p>
</div>
</div>
<div class="section" id="id11">
<h2>端口<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>端口提供了与外部世界通讯的基本机制。用Erlang编写的应用程序往往需要与Erlang系统之外的对象交互。还有一些现存的软件包，例如窗口系统、数据库系统，或是使用C、Modula2等其他语言的程序，在使用它们构建复杂系统时，也往往需要给它们提供Erlang接口。</p>
<p>从程序员的视角来看，我们希望能够以处理普通Erlang程序的方式来处理Erlang系统外的所有活动。为了创造这样的效果，我们需要将Erlang系统外的对象伪装成普通的Erlang进程。<strong>端口</strong>（Port），一种为Erlang系统和外部世界提供面向字节的通讯信道的抽象设施，就是为此而设计的。</p>
<p>执行<tt class="docutils literal"><span class="pre">open_port(PortName,</span> <span class="pre">PortSettings)</span></tt>可以创建一个端口，其行为与进程类似。执行<tt class="docutils literal"><span class="pre">open_port</span></tt>的进程称为该端口的<strong>连接进程</strong>。需要发送给端口的消息都应发送至连接进程。外部对象可以通过向与之关联的端口写入字节序列的方式向Erlang系统发送消息，端口将给连接进程发送一条包含该字节序列的消息。</p>
<p>系统中的任意进程都可以与一个端口建立链接，端口和Erlang进程间的<tt class="docutils literal"><span class="pre">EXIT</span></tt>信号导致的行为与普通进程的情况完全一致。端口只理解<strong>三种</strong>消息：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="nv">PidC</span><span class="p">,</span> <span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="nv">Data</span><span class="p">}}</span>
<span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="nv">PidC</span><span class="p">,</span> <span class="p">{</span><span class="n">connect</span><span class="p">,</span> <span class="nv">Data</span><span class="p">}}</span>
<span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="nv">PidC</span><span class="p">,</span> <span class="n">close</span><span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PidC</span></tt><strong>必须</strong>是一个连接进程的<tt class="docutils literal"><span class="pre">Pid</span></tt>。这些消息的含义如下：</p>
<p><tt class="docutils literal"><span class="pre">{command,</span> <span class="pre">Data}</span></tt></p>
<blockquote>
<div>将<tt class="docutils literal"><span class="pre">Data</span></tt>描述的字节序列发送给外部对象。<tt class="docutils literal"><span class="pre">Data</span></tt>可以是单个二进制对象，也可以是一个元素为<tt class="docutils literal"><span class="pre">0..255</span></tt>范围内的整数的非扁平列表<a class="footnote-reference" href="#id24" id="id12">[2]</a>。没有响应。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">close</span></tt></p>
<blockquote>
<div>关闭端口。端口将向连接进程回复一条<tt class="docutils literal"><span class="pre">{Port,</span> <span class="pre">closed}</span></tt>消息。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">{connect,</span> <span class="pre">Pid1}</span></tt></p>
<blockquote>
<div>将端口的连接进程换位<tt class="docutils literal"><span class="pre">Pid1</span></tt>。端口将向先前的连接进程发送一条<tt class="docutils literal"><span class="pre">{Port,</span> <span class="pre">connected}</span></tt>消息。</div></blockquote>
<p>此外，连接进程还可以通过以下方式接收数据消息：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">receive</span>
    <span class="p">{</span><span class="nv">Port</span><span class="p">,</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="nv">Data</span><span class="p">}}</span> <span class="o">-&gt;</span>
        <span class="p">...</span> <span class="n">an</span> <span class="n">external</span> <span class="n">object</span> <span class="n">has</span> <span class="n">sent</span> <span class="n">data</span> <span class="n">to</span> <span class="nv">Erlang</span> <span class="p">...</span>
    <span class="p">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在这一节中，我们将描述两个使用端口的程序：第一个是在Erlang工作空间<strong>内部</strong>的Erlang进程；第二个是在Erlang<strong>外部</strong>执行的C程序。</p>
<div class="section" id="id13">
<h3>打开端口<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>打开端口时可以进行多种设置。BIF <tt class="docutils literal"><span class="pre">open_port(PortName,</span> <span class="pre">PortSettings</span></tt>可用于打开端口。<tt class="docutils literal"><span class="pre">PortName</span></tt>可以是：</p>
<p><tt class="docutils literal"><span class="pre">{spawn,</span> <span class="pre">Command}</span></tt></p>
<blockquote>
<div>启动名为<tt class="docutils literal"><span class="pre">Command</span></tt>的<strong>外部</strong>程序或驱动。Erlang驱动在附录E中有所描述。若没有找到名为<tt class="docutils literal"><span class="pre">Command</span></tt>的驱动，则将在Erlang工作空间的外部运行名为<tt class="docutils literal"><span class="pre">Command</span></tt>的外部程序。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">Atom</span></tt></p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">Atom</span></tt>将被认作是外部资源的名称。这样将在Erlang系统和由该原子式命名的资源之间建立一条透明的连接。连接的行为取决于资源的类型。如果<tt class="docutils literal"><span class="pre">Atom</span></tt>表示一个文件，则一条包含文件全部内容的消息会被发送给Erlang系统；向该端口写入发送消息便可向文件写入数据。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">{fd,</span> <span class="pre">In,</span> <span class="pre">Out}</span></tt></p>
<blockquote>
<div>令Erlang进程得以访问任意由Erlang打开的文件描述符。文件描述符<tt class="docutils literal"><span class="pre">In</span></tt>可作为标准输入而<tt class="docutils literal"><span class="pre">Out</span></tt>可作为标准输出。该功能很少使用：只有Erlang操作系统的几种服务（<tt class="docutils literal"><span class="pre">shell</span></tt>和<tt class="docutils literal"><span class="pre">user</span></tt>）需要使用。注意该功能与仅限于UNIX系统。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">PortSettings</span></tt>是端口设置的列表。有效的设置有：</p>
<p><tt class="docutils literal"><span class="pre">{packet,</span> <span class="pre">N}</span></tt></p>
<blockquote>
<div>消息的长度将以大端字节序附在消息内容之前的<tt class="docutils literal"><span class="pre">N</span></tt>个字节内。<tt class="docutils literal"><span class="pre">N</span></tt>的有效取值为<tt class="docutils literal"><span class="pre">1</span></tt>、<tt class="docutils literal"><span class="pre">2</span></tt>或<tt class="docutils literal"><span class="pre">4</span></tt>。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">stream</span></tt></p>
<blockquote>
<div>输出的消息不附带消息长度──Erlang进程和外部对象间必须使用某种私有协议。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">use_stdio</span></tt></p>
<blockquote>
<div>仅对<tt class="docutils literal"><span class="pre">{spawn,</span> <span class="pre">Command}</span></tt>形式的端口有效。令产生的（UNIX）进程使用标准输入输出（即文件标识符<tt class="docutils literal"><span class="pre">0</span></tt>和<tt class="docutils literal"><span class="pre">1</span></tt>）与Erlang通讯。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">nouse_stdio</span></tt></p>
<blockquote>
<div>与上述相反。使用文件描述符<tt class="docutils literal"><span class="pre">3</span></tt>、<tt class="docutils literal"><span class="pre">4</span></tt>与Erlang通讯。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">in</span></tt></p>
<blockquote>
<div>端口仅用于输入。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">out</span></tt></p>
<blockquote>
<div>端口仅用于输出。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">binary</span></tt></p>
<blockquote>
<div>端口为二进制端口（后续将详述）。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">eof</span></tt></p>
<blockquote>
<div>到达文件末尾后端口不会关闭并发送<tt class="docutils literal"><span class="pre">'EXIT'</span></tt>信号，而是保持打开状态并向端口的连接进程发送一条<tt class="docutils literal"><span class="pre">{Port,</span> <span class="pre">eof}</span></tt>消息，之后连接进程仍可向端口输出数据。</div></blockquote>
<p>除了<tt class="docutils literal"><span class="pre">{spawn,</span> <span class="pre">Command}</span></tt>类型的端口默认使用<tt class="docutils literal"><span class="pre">use_stdio</span></tt>外，*所有*类型的端口默认都使用<tt class="docutils literal"><span class="pre">stream</span></tt>。</p>
</div>
<div class="section" id="erlang">
<h3>Erlang进程眼中的端口<a class="headerlink" href="#erlang" title="永久链接至标题">¶</a></h3>
<p>程序9.2定义了一个简单的Erlang进程，该进程打开一个端口并向该端口发送一串消息。与端口相连的外部对象会处理并回复这些消息。一段时间之后进程将关闭端口。</p>
<div class="topic">
<p class="topic-title first">程序9.2</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">demo_server</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="nf">start</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nv">Port</span> <span class="o">=</span> <span class="nb">open_port</span><span class="p">({</span><span class="nb">spawn</span><span class="p">,</span> <span class="n">demo_server</span><span class="p">},</span> <span class="p">[{</span><span class="n">packet</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]),</span>
    <span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]}},</span>
    <span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="n">command</span><span class="p">},</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]},</span>
    <span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="s">&quot;echo&quot;</span><span class="p">}},</span>
    <span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">}},</span>
    <span class="n">read_replies</span><span class="p">(</span><span class="nv">Port</span><span class="p">).</span>

<span class="nf">read_replies</span><span class="p">(</span><span class="nv">Port</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">receive</span>
        <span class="p">{</span><span class="nv">Port</span><span class="p">,</span> <span class="nv">Any</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nn">io</span><span class="p">:</span><span class="n">format</span><span class="p">(</span><span class="n">&#39;erlang received from port:~w~n&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Any</span><span class="p">]),</span>
            <span class="n">read_replies</span><span class="p">(</span><span class="nv">Port</span><span class="p">)</span>
    <span class="k">after</span> <span class="mi">2000</span> <span class="o">-&gt;</span>
            <span class="nv">Port</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="n">close</span><span class="p">},</span>
            <span class="k">receive</span>
                <span class="p">{</span><span class="nv">Port</span><span class="p">,</span> <span class="n">closed</span><span class="p">}</span> <span class="o">-&gt;</span>
                    <span class="n">true</span>
            <span class="k">end</span>
    <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>程序9.2中的<tt class="docutils literal"><span class="pre">open_port(PortName,</span> <span class="pre">PortSettings</span></tt>启动了一个<strong>外部</strong>程序。<tt class="docutils literal"><span class="pre">demo_server</span></tt>是即将运行的程序的名字。</p>
<p>表达式<tt class="docutils literal"><span class="pre">Port</span> <span class="pre">!</span> <span class="pre">{self(),</span> <span class="pre">{command,</span> <span class="pre">[1,2,3,4,5]}}</span></tt>向外部程序发送了五个字节（值为1、2、3、4、5）。</p>
<p>为了让事情有意思一点，我们令外部程序具备一下功能：</p>
<ul class="simple">
<li>若程序收到字符串“echo”，则它会向Erlang回复“ohce”。</li>
<li>若程序收到的数据块的第一个字节是10，则它会将除第一个字节以外的所有字节翻倍后返回。</li>
<li>忽略其他数据。</li>
</ul>
<p>运行该程序后我们得到以下结果：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">demo_server</span><span class="p">:</span><span class="n">start</span><span class="p">().</span>
<span class="n">erlang</span> <span class="n">received</span> <span class="n">from</span> <span class="nn">port</span><span class="p">:{</span><span class="n">data</span><span class="p">,[</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]}</span>
<span class="n">erlang</span> <span class="n">received</span> <span class="n">from</span> <span class="nn">port</span><span class="p">:{</span><span class="n">data</span><span class="p">,[</span><span class="mi">111</span><span class="p">,</span><span class="mi">104</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">101</span><span class="p">]}</span>
<span class="n">true</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>外部进程眼中的端口<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<div class="topic">
<p class="topic-title first">程序9.3</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95</pre></td><td class="code"><div class="highlight"><pre><span class="c">/* demo_server.c */</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="c">/* Message data are all unsigned bytes */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">byte</span><span class="p">;</span>

<span class="n">main</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">progname</span><span class="p">;</span>
    <span class="n">byte</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>

    <span class="n">progname</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>         <span class="c">/* Save start name of program */</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;demo_server in C Starting </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">len</span> <span class="o">=</span> <span class="n">read_cmd</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;echo&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
          <span class="n">write_cmd</span><span class="p">(</span><span class="s">&quot;ohce&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span><span class="p">){</span>
          <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="n">write_cmd</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">/* Read the 2 length bytes (MSB first), then the data. */</span>
<span class="n">read_cmd</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">read_exact</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">read_exact</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">/* Pack the 2 bytes length (MSB first) and send it */</span>
<span class="n">write_cmd</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">byte</span> <span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">put_int16</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write_exact</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">write_exact</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">/* [read|write]_exact are used since they may return</span>
<span class="c"> * BEFORE all bytes have been transmitted</span>
<span class="c"> */</span>
<span class="n">read_exact</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">got</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">got</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">got</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">got</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">got</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">write_exact</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span>
<span class="n">byte</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">wrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">wrote</span><span class="p">,</span> <span class="n">len</span><span class="o">-</span><span class="n">wrote</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">wrote</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wrote</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">put_int16</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">byte</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="p">{</span>
    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<p>程序9.3通过表达式<tt class="docutils literal"><span class="pre">len</span> <span class="pre">=</span> <span class="pre">read_cmd(buf)</span></tt>读取发送至Erlang端口的字节序列，并用<tt class="docutils literal"><span class="pre">write_cmd(buf,</span> <span class="pre">len)</span></tt>将数据发回Erlang。</p>
<p>文件描述符0用于从Erlang读取数据，而文件描述符1用于向Erlang写入数据。各个C函数的功能如下：</p>
<p><tt class="docutils literal"><span class="pre">read_cmd(buf)</span></tt></p>
<blockquote>
<div>从Erlang读取一条命令。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">write_cmd(buf,</span> <span class="pre">len)</span></tt></p>
<blockquote>
<div>向Erlang写入一个长度为<tt class="docutils literal"><span class="pre">len</span></tt>的缓冲区。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">read_exact(buf,</span> <span class="pre">len)</span></tt></p>
<blockquote>
<div>读取<tt class="docutils literal"><span class="pre">len</span></tt>个字节。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">write_exact(buf,</span> <span class="pre">len)</span></tt></p>
<blockquote>
<div>写入<tt class="docutils literal"><span class="pre">len</span></tt>个字节。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">put_int16(i,</span> <span class="pre">s)</span></tt></p>
<blockquote>
<div>将一个16位整数打包为两个字节。</div></blockquote>
<p>函数<tt class="docutils literal"><span class="pre">read_cmd</span></tt>和<tt class="docutils literal"><span class="pre">write_cmd</span></tt>假设外部服务和Erlang间的协议由一个指明数据包长度的双字节包头和紧随的数据构成。如图9.1所示。</p>
<div class="figure">
<img alt="_images/9.1.png" src="_images/9.1.png" />
<p class="caption">图9.1 端口通讯</p>
</div>
<p>之所以使用这种协议（双字节包头加数据）是由于端口是以如下方式打开的：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nb">open_port</span><span class="p">({</span><span class="nb">spawn</span><span class="p">,</span> <span class="n">demo_server</span><span class="p">},</span> <span class="p">[{</span><span class="n">packet</span><span class="p">,</span> <span class="mi">2</span><span class="p">}])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id15">
<h2>二进制类型<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<p>二进制类型是一种用于存储无类型内存区域的数据类型。若<tt class="docutils literal"><span class="pre">open_port/2</span></tt>的最后一个参数<tt class="docutils literal"><span class="pre">Settings</span></tt>列表中包含原子式<tt class="docutils literal"><span class="pre">binary</span></tt>，则打开的端口便是二进制端口。来自二进制端口的消息都是二进制类型的数据。</p>
<p>为了说明二进制端口和普通端口的区别，我们用“双字节包头加数据”协议从外部进程向Erlang发送字符串<tt class="docutils literal"><span class="pre">&quot;hello&quot;</span></tt>。外部程序将输出如下字节序列：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="mi">0</span> <span class="mi">5</span> <span class="mi">104</span> <span class="mi">101</span> <span class="mi">108</span> <span class="mi">108</span> <span class="mi">111</span>
</pre></div>
</div>
<p>若与Erlang进程相连的端口是普通端口，则会向向进程发送消息<tt class="docutils literal"><span class="pre">{Port,</span> <span class="pre">{data,</span> <span class="pre">[104,</span> <span class="pre">101,</span> <span class="pre">108,</span> <span class="pre">108,</span> <span class="pre">111]}}</span></tt>。若是二进制端口，消息则是<tt class="docutils literal"><span class="pre">{Port,</span> <span class="pre">{data,</span> <span class="pre">Bin}}</span></tt>，其中<tt class="docutils literal"><span class="pre">Bin</span></tt>是长度为5的二进制数据对象，内容即为消息中的字节数据。注意，在这两种情况下，向端口发送数据的外部进程没有区别。</p>
<p>令端口发送二进制对象而非列表的好处在于，相对于长列表，构造和发送二进制数据的速度要快很多。</p>
<p>下列BIF可用于二进制操作：</p>
<p><tt class="docutils literal"><span class="pre">term_to_binary(T)</span></tt></p>
<blockquote>
<div>将项式<tt class="docutils literal"><span class="pre">T</span></tt>转为二进制。得到的二进制数据对象为该项式的<strong>外部项式格式</strong>表示。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">binary_to_term(Bin)</span></tt></p>
<blockquote>
<div>与<tt class="docutils literal"><span class="pre">term_to_binary/1</span></tt>相反。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">binary_to_list(Bin)</span></tt></p>
<blockquote>
<div>将二进制对象<tt class="docutils literal"><span class="pre">Bin</span></tt>转为证书列表。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">binary_to_list(Bin,</span> <span class="pre">Start,</span> <span class="pre">Stop)</span></tt></p>
<blockquote>
<div>将二进制对象从<tt class="docutils literal"><span class="pre">Start</span></tt>到<tt class="docutils literal"><span class="pre">Stop</span></tt>的部分转为整数列表。二进制对象的位置下标从1开始计算。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">list_to_binary(Charlist)</span></tt></p>
<blockquote>
<div>将<tt class="docutils literal"><span class="pre">Charlist</span></tt>转为二进制数据对象。与<tt class="docutils literal"><span class="pre">term_to_binary(Charlist)</span></tt> 不同，该BIF构造的是一个包含<tt class="docutils literal"><span class="pre">Charlist</span></tt>所包含的字节序列的二进制对象，而前者是针对<strong>项式</strong><tt class="docutils literal"><span class="pre">Charlist</span></tt>构造一个外部项式格式的二进制对象。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">split_binary(Bin,</span> <span class="pre">Pos)</span></tt></p>
<blockquote>
<div><p>将<tt class="docutils literal"><span class="pre">Bin</span></tt>从<tt class="docutils literal"><span class="pre">Pos</span></tt>处切分为两个新的二进制对象。得到的是包含两个新二进制对象的元组。例如：</p>
<div class="highlight-erlang"><pre>1&gt; B = list_to_binary("0123456789").
#Bin
2&gt; size(B).
10
3&gt; {B1,B2} = split_binary(B,3).
{#Bin,#Bin}
4&gt; size(B1).
3
5&gt; size(B2).
7</pre>
</div>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">concat_binary(ListOfBinaries)</span></tt></p>
<blockquote>
<div>构造一个串接二进制对象列表<tt class="docutils literal"><span class="pre">ListOfBinaries</span></tt>中的所有二进制对象的新二进制对象。</div></blockquote>
<p>另外，保护式<tt class="docutils literal"><span class="pre">binary(X)</span></tt>在<tt class="docutils literal"><span class="pre">X</span></tt>为二进制数据对象时返回成功。二进制对象主要用于网络中的代码加载，但也可用于那些需要处理大量音视频数据等原始数据的应用。通常可以高效地通过端口输入大量二进制数据，完成数据处理后，再输出到另一个或原先的端口。</p>
</div>
<div class="section" id="id16">
<h2>进程字典<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h2>
<p>每个进程都拥有一个字典。通过下列BIF可以操作该字典：</p>
<p><tt class="docutils literal"><span class="pre">put(Key,</span> <span class="pre">Value)</span></tt></p>
<blockquote>
<div>将与键<tt class="docutils literal"><span class="pre">Key</span></tt>相关联的新值<tt class="docutils literal"><span class="pre">Value</span></tt>加入进程字典。若与<tt class="docutils literal"><span class="pre">Key</span></tt>相关联的值已经存在则该值将被删除并被新值<tt class="docutils literal"><span class="pre">Value</span></tt>替代。该BIF返回原先与<tt class="docutils literal"><span class="pre">Key</span></tt>关联的值，若原先没有值与<tt class="docutils literal"><span class="pre">Key</span></tt>相关联，则返回<tt class="docutils literal"><span class="pre">undefined</span></tt>。<tt class="docutils literal"><span class="pre">Key</span></tt>和<tt class="docutils literal"><span class="pre">Value</span></tt>可以是任意的Erlang项式。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">get(Key)</span></tt></p>
<blockquote>
<div>返回进程字典中与<tt class="docutils literal"><span class="pre">Key</span></tt>关联的值。若没有值与<tt class="docutils literal"><span class="pre">Key</span></tt>相关联则返回<tt class="docutils literal"><span class="pre">undefined</span></tt>。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">get()</span></tt></p>
<blockquote>
<div>以<tt class="docutils literal"><span class="pre">{Key,</span> <span class="pre">Value}</span></tt>元组列表的形式返回整个进程字典。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">get_keys(Value)</span></tt></p>
<blockquote>
<div>返回一个列表，包含进程字典中值为<tt class="docutils literal"><span class="pre">Value</span></tt>的所有的键。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">erase(Key)</span></tt></p>
<blockquote>
<div>返回整个进程字典后将至删除。</div></blockquote>
<p>对于各个进程而言进程字典是<strong>局部</strong>的。进程刚被创建时进程字典为空。任何函数都可通过调用<tt class="docutils literal"><span class="pre">put(Key,</span> <span class="pre">Value)</span></tt>向字典中添加<tt class="docutils literal"><span class="pre">{Key,</span> <span class="pre">Value}</span></tt>键值对，而后再通过调用<tt class="docutils literal"><span class="pre">get(Key)</span></tt>取出。在<tt class="docutils literal"><span class="pre">catch</span></tt>作用域内，若在调用<tt class="docutils literal"><span class="pre">put</span></tt>后调用<tt class="docutils literal"><span class="pre">throw</span></tt>或出现错误，放入字典的值不会被撤回。</p>
<p>借助<tt class="docutils literal"><span class="pre">get()</span></tt>和<tt class="docutils literal"><span class="pre">erase()</span></tt>可以获取或删除整个字典。删除单个条目可用<tt class="docutils literal"><span class="pre">erase(Key)</span></tt>。</p>
<p>有时候我们希望在多个不同函数中访问同一块全局数据，而将之作为进程中所有函数的参数来进行传递又不太方便。小心使用<tt class="docutils literal"><span class="pre">put</span></tt>和<tt class="docutils literal"><span class="pre">get</span></tt>就可以避免这个问题。</p>
<p><tt class="docutils literal"><span class="pre">get</span></tt>和<tt class="docutils literal"><span class="pre">set</span></tt>在语言中引入了破坏性操作，令程序员写出具有副作用的函数。这些函数的调用结果可能跟它们的调用次序相关。对进程字典的使用应该<strong>非常小心</strong>。<tt class="docutils literal"><span class="pre">get</span></tt>和<tt class="docutils literal"><span class="pre">set</span></tt>就好比传统命令式语言里的<em>goto</em>。<tt class="docutils literal"><span class="pre">get</span></tt>和<tt class="docutils literal"><span class="pre">set</span></tt>在某些特定场景下很有用，但使用它们会造成不清晰的代码，应该尽可能地避免使用。鉴于不鼓励使用进程字典，本书的所有程序都不使用进程字典——为了内容完整，只在此处和附录中包含相关内容。</p>
</div>
<div class="section" id="id17">
<h2>网络内核<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">net_kernel</span></tt>进程被用于协调分布式Erlang系统。运行时系统会自动向<tt class="docutils literal"><span class="pre">net_kernel</span></tt>发送某些消息。在该进程中执行的代码决定对于不同的系统消息应该采取何种动作。</p>
<p>Erlang系统可在两种模式下运行。它可以作为一个不与其他Erlang系统通讯的封闭系统运行，也可以同其他系统进行通讯，这时我们认为它<strong>存活</strong>着。通过调用BIF  <tt class="docutils literal"><span class="pre">alive/2</span></tt>可以令系统活过来。通常这是由Erlang操作系统而不是用户完成的。以下调用：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nn">erlang</span><span class="p">:</span><span class="n">alive</span><span class="p">(</span><span class="nv">Name</span><span class="p">,</span> <span class="nv">Port</span><span class="p">)</span>
</pre></div>
</div>
<p>将通知网络命名服务一个Erlang系统已经启动并可以参与分布式计算了。</p>
<p><tt class="docutils literal"><span class="pre">Name</span></tt>是一个用于标识该Erlang系统的本地名称。该Erlang系统的外部名称为<tt class="docutils literal"><span class="pre">Name&#64;MachineName</span></tt>，其中<tt class="docutils literal"><span class="pre">MachineName</span></tt>是节点所在的机器名，而字符“<tt class="docutils literal"><span class="pre">&#64;</span></tt>”用于分隔本地名称与机器名。例如，在名为<tt class="docutils literal"><span class="pre">super.eua.ericsson.se</span></tt>的主机上调用<tt class="docutils literal"><span class="pre">erlang:alive(foo,Port)</span></tt>将会启动一个名为<tt class="docutils literal"><span class="pre">foo&#64;super.eua.ericsson.se</span></tt>的Erlang系统，该名称全局唯一。在同一台机器上可以同时运行多个本地名不同的Erlang系统。</p>
<p><tt class="docutils literal"><span class="pre">Port</span></tt>是一个Erlang端口。外部端口程序必须遵从Erlang分布式系统的内部协议。该程序负责所有的网络操作，如建立与远程节点间的通讯信道以及向这些节点的字节缓冲区读写数据。不同版本的端口程序允许Erlang节点采用不同的网络技术进行通讯。</p>
<p>执行<tt class="docutils literal"><span class="pre">alive/2</span></tt>将使执行该表达式的进程被加入一个可参与分布式计算的Erlang节点池。执行<tt class="docutils literal"><span class="pre">alive/2</span></tt>的进程必须以<tt class="docutils literal"><span class="pre">net_kernel</span></tt>为名进行注册。否则，该BIF调用会失败。要将一个节点从网路中断开，可以关闭分布式端口。</p>
<p>BIF <tt class="docutils literal"><span class="pre">is_alive()</span></tt>可用于检测一个节点是否存活。该BIF返回<tt class="docutils literal"><span class="pre">true</span></tt>或<tt class="docutils literal"><span class="pre">false</span></tt>。</p>
<p>一旦有新节点出现，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>就会收到一条<tt class="docutils literal"><span class="pre">{nodeup,</span> <span class="pre">Node}</span></tt>消息；一旦有节点失败，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>也相应会收到一条<tt class="docutils literal"><span class="pre">{nodedown,</span> <span class="pre">Node}</span></tt>消息。所有调用<tt class="docutils literal"><span class="pre">spawn/4</span></tt>或<tt class="docutils literal"><span class="pre">spawn_link/4</span></tt>的进程创建请求以及所有采用<tt class="docutils literal"><span class="pre">{Name,</span> <span class="pre">Node}</span> <span class="pre">!</span> <span class="pre">Message</span></tt>结构向远程注册进程发送消息的请求都会经过<tt class="docutils literal"><span class="pre">net_kernel</span></tt>进程。这使得用户可以通过自定义<tt class="docutils literal"><span class="pre">net_kernel</span></tt>代码来达成多种目的。例如，BIF <tt class="docutils literal"><span class="pre">spawn/4</span></tt>实际上是用Erlang自身实现的。在远程节点创建进程的客户端代码为：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nb">spawn</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">A</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">/=</span> <span class="nb">node</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nb">monitor_node</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="n">true</span><span class="p">),</span>
    <span class="p">{</span><span class="n">net_kernel</span><span class="p">,</span> <span class="nv">N</span><span class="p">}</span> <span class="o">!</span> <span class="p">{</span><span class="n">self</span><span class="p">(),</span> <span class="nb">spawn</span><span class="p">,</span> <span class="nv">M</span><span class="p">,</span> <span class="nv">F</span><span class="p">,</span> <span class="nv">A</span><span class="p">,</span> <span class="nb">group_leader</span><span class="p">()},</span>
    <span class="k">receive</span>
        <span class="p">{</span><span class="n">nodedown</span><span class="p">,</span> <span class="nv">N</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nv">R</span> <span class="o">=</span> <span class="nb">spawn</span><span class="p">(</span><span class="n">erlang</span><span class="p">,</span> <span class="n">crasher</span><span class="p">,</span> <span class="p">[</span><span class="nv">N</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="n">noconnection</span><span class="p">]);</span>
        <span class="p">{</span><span class="n">spawn_reply</span><span class="p">,</span> <span class="nv">Pid</span><span class="p">}</span> <span class="o">-&gt;</span>
            <span class="nv">R</span> <span class="o">=</span> <span class="nv">Pid</span>
    <span class="k">end</span><span class="p">,</span>
    <span class="nb">monitor_node</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="n">false</span><span class="p">),</span>
    <span class="nv">R</span><span class="p">;</span>
<span class="nb">spawn</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">A</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">spawn</span><span class="p">(</span><span class="nv">M</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">A</span><span class="p">).</span>

<span class="nf">crasher</span><span class="p">(</span><span class="nv">Node</span><span class="p">,</span><span class="nv">Mod</span><span class="p">,</span><span class="nv">Fun</span><span class="p">,</span><span class="nv">Args</span><span class="p">,</span><span class="nv">Reason</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">exit</span><span class="p">(</span><span class="nv">Reason</span><span class="p">).</span>
</pre></div>
</div>
<p>这段代码的效果是向远程节点上的<tt class="docutils literal"><span class="pre">net_kernel</span></tt>进程发送一条消息。远程的<tt class="docutils literal"><span class="pre">net_kernel</span></tt>负责创建新进程，并告知客户端新进程的Pid。</p>
<div class="section" id="id18">
<h3>认证<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<p>Erlang系统采用“magic cookies”的方式内建了认证支持。Magic cookie是分配给各个节点的一个保密原子式。每个节点在启动时都会被自动分配一个随机cookie。节点<tt class="docutils literal"><span class="pre">N1</span></tt>要想和节点<tt class="docutils literal"><span class="pre">N2</span></tt>通讯，就必须知道<tt class="docutils literal"><span class="pre">N2</span></tt>的magic cookie。这里不讨论<tt class="docutils literal"><span class="pre">N1</span></tt>如何找出<tt class="docutils literal"><span class="pre">N2</span></tt>的cookie。为了令<tt class="docutils literal"><span class="pre">N1</span></tt>得以和<tt class="docutils literal"><span class="pre">N2</span></tt>通讯，<tt class="docutils literal"><span class="pre">N1</span></tt>必须执行<tt class="docutils literal"><span class="pre">erlang:set_cookie(N2,</span> <span class="pre">N2Cookie)</span></tt>，其中<tt class="docutils literal"><span class="pre">N2Cookie</span></tt>是<tt class="docutils literal"><span class="pre">N2</span></tt>的cookie值。另外，要令<tt class="docutils literal"><span class="pre">N1</span></tt>能够收到来自<tt class="docutils literal"><span class="pre">N2</span></tt>的响应，<tt class="docutils literal"><span class="pre">N2</span></tt>也必须执行<tt class="docutils literal"><span class="pre">erlang:set_cookie(N1,</span> <span class="pre">N1Cookie</span></tt>，其中<tt class="docutils literal"><span class="pre">N1Cookie</span></tt>是<tt class="docutils literal"><span class="pre">N1</span></tt>的cookie值。</p>
<p>Erlang运行时系统会将cookie插入到发送给所有远程节点的所有消息中。若一条消息抵达某节点时携带着错误的cookie，则运行时系统会将这条消息转换为以下格式：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">From</span><span class="p">,</span><span class="n">badcookie</span><span class="p">,</span><span class="nv">To</span><span class="p">,</span><span class="nv">Message</span><span class="p">}</span>
</pre></div>
</div>
<p>其中<tt class="docutils literal"><span class="pre">To</span></tt>是消息接收方的Pid或注册名而<tt class="docutils literal"><span class="pre">From</span></tt>是发送方的Pid。所有未认证的消息发送请求和进程创建请求都会被转为<tt class="docutils literal"><span class="pre">badcookie</span></tt>消息并发送至<tt class="docutils literal"><span class="pre">net_kernel</span></tt>。<tt class="docutils literal"><span class="pre">net_kernel</span></tt>可以任意处置<tt class="docutils literal"><span class="pre">badcookie</span></tt>消息。</p>
<p>以下两个BIF可用于cookie操作：</p>
<p><tt class="docutils literal"><span class="pre">erlang:get_cookie()</span></tt></p>
<blockquote>
<div>返回自己的magic cookie。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">erlang:set_cookie(Node,Cookie)</span></tt></p>
<blockquote>
<div>将节点<tt class="docutils literal"><span class="pre">Node</span></tt>的magic cookie设置为<tt class="docutils literal"><span class="pre">Cookie</span></tt>。获得<tt class="docutils literal"><span class="pre">Node</span></tt>的cookie后可以使用该BIF。它将令后续发送给<tt class="docutils literal"><span class="pre">Node</span></tt>的所有消息都包含<tt class="docutils literal"><span class="pre">Cookie</span></tt>。如果<tt class="docutils literal"><span class="pre">Cookie</span></tt>确实是<tt class="docutils literal"><span class="pre">Node</span></tt>的magic cookie，则消息将直接被发送至<tt class="docutils literal"><span class="pre">Node</span></tt>上的接收进程。如果包含的cookie有误，该消息将在接收端被转为<tt class="docutils literal"><span class="pre">badcookie</span></tt>消息，再被发送至那里的<tt class="docutils literal"><span class="pre">net_kernel</span></tt>。</div></blockquote>
<p>默认情况下，所有节点都假定所有其他节点的cookie是原子式<tt class="docutils literal"><span class="pre">nocookie</span></tt>，因此初始时所有的远程消息都包含cookie <tt class="docutils literal"><span class="pre">nocookie</span></tt>。</p>
<p>若调用<tt class="docutils literal"><span class="pre">erlang:set_cookie(Node,</span> <span class="pre">Cookie)</span></tt>时<tt class="docutils literal"><span class="pre">Node</span></tt>的值为本地节点的名字，则本地节点的magic cookie将被设置为<tt class="docutils literal"><span class="pre">Cookie</span></tt>，同时，其他所有cookie值为<tt class="docutils literal"><span class="pre">nocookie</span></tt>的节点都会变为<tt class="docutils literal"><span class="pre">Cookie</span></tt>。如果所有节点都在启动时执行：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nn">erlang</span><span class="p">:</span><span class="nb">set_cookie</span><span class="p">(</span><span class="nb">node</span><span class="p">(),</span> <span class="nv">SecretCookie</span><span class="p">),</span>
</pre></div>
</div>
<p>则它们将自动互相认证以便协作。应用如何获取到<tt class="docutils literal"><span class="pre">SecretCookie</span></tt>是一个实现问题。保密cookie应保存于一个仅能由用户读取或仅能由用户组读取的文件中。</p>
<p>在UNIX环境下，节点启动后的默认行为是读取用户HOME目录下名为<tt class="docutils literal"><span class="pre">.erlang.cookie</span></tt>的文件。首先将会对文件的保护权限进行检查，然后便会调用<tt class="docutils literal"><span class="pre">erlang:set_cookie(node(),</span> <span class="pre">Cookie)</span></tt>，其中<tt class="docutils literal"><span class="pre">Cookie</span></tt>是包含cookie文件内容的原子式。之后，同一用户就可以安全地与其他所有在相同用户ID下运行的Erlang节点进行通讯了（假设所有节点都在同一文件系统下运行）。如果节点驻留在不同的文件系统中，用户只须保证涉及到的文件系统中的cookie文件的内容相同即可。</p>
</div>
<div class="section" id="net-kernel">
<h3>net_kernel消息<a class="headerlink" href="#net-kernel" title="永久链接至标题">¶</a></h3>
<p>以下是可以发送给<tt class="docutils literal"><span class="pre">net_kernel</span></tt>的消息的列表：</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">{From,registered_send,To,Mess}</span></tt> 向注册进程<tt class="docutils literal"><span class="pre">To</span></tt>的发送消息<tt class="docutils literal"><span class="pre">Mess</span></tt>的请求。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">{From,spawn,M,F,A,Gleader}</span></tt> 创建新进程的请求。<tt class="docutils literal"><span class="pre">Gleader</span></tt>是请求发起方进程的group leader。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">{From,spawn_link,M,F,a,Gleader}</span></tt> 创建新进程并向新进程建立链接的请求。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">{nodeup,Node}</span></tt> 当系统中有新节点接入时，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>就会收到该消息。这种情况既可能是某远程节点来联络我们，也可能是本地节点上的某个进程向该远程节点首次完成了一次远程操作。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">{nodedown,Node}</span></tt> 当某节点失败或从本地节点无法联络到某远程节点时，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>就会收到该消息。</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">{From,badcookie,To,Mess}</span></tt> 当有未认证请求发送到本节点时，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>就会收到一条可表征该请求性质的消息。例如，某未认证节点发起了一个进程创建请求，<tt class="docutils literal"><span class="pre">net_kernel</span></tt>就会收到消息：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">From</span><span class="p">,</span><span class="n">badcookie</span><span class="p">,</span> <span class="n">net_kernel</span><span class="p">,</span> <span class="p">{</span><span class="nv">From</span><span class="p">,</span><span class="nb">spawn</span><span class="p">,</span><span class="nv">M</span><span class="p">,</span><span class="nv">F</span><span class="p">,</span><span class="nv">A</span><span class="p">,</span><span class="nv">Gleader</span><span class="p">}}</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="id19">
<h2>散列<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<p>Erlang提供了一个可从任意项式产生一个整数散列值的BIF：</p>
<p><tt class="docutils literal"><span class="pre">hash(Term,</span> <span class="pre">MaxInt)</span></tt></p>
<blockquote>
<div>返回一个在<tt class="docutils literal"><span class="pre">1..MaxInt</span></tt>范围内的整数。</div></blockquote>
<p>借助<tt class="docutils literal"><span class="pre">hash</span></tt> BIF我们可以编写一个高效的字典查询程序。该程序的接口与第??节的二叉树实现的字典几乎完全一样。</p>
<div class="topic">
<p class="topic-title first">程序9.4</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">tupleStore</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">new</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span><span class="n">new</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span><span class="n">lookup</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">add</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="n">delete</span><span class="o">/</span><span class="mi">2</span><span class="p">]).</span>

<span class="nf">new</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="n">new</span><span class="p">(</span><span class="mi">256</span><span class="p">).</span>

<span class="nf">new</span><span class="p">(</span><span class="nv">NoOfBuckets</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">make_tuple</span><span class="p">(</span><span class="nv">NoOfBuckets</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">lookup</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">lookup_in_list</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nb">element</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Tuple</span><span class="p">)),</span> <span class="nv">Tuple</span><span class="p">)).</span>

<span class="nf">add</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Index</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Tuple</span><span class="p">)),</span>
    <span class="nv">Old</span>   <span class="o">=</span> <span class="nb">element</span><span class="p">(</span><span class="nv">Index</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">),</span>
    <span class="nv">New</span>   <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="nv">Old</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="nb">setelement</span><span class="p">(</span><span class="nv">Index</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">,</span> <span class="nv">New</span><span class="p">).</span>

<span class="nf">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Index</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Tuple</span><span class="p">)),</span>
    <span class="nv">Old</span>   <span class="o">=</span> <span class="nb">element</span><span class="p">(</span><span class="nv">Index</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">),</span>
    <span class="nv">New</span>   <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Old</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="nb">setelement</span><span class="p">(</span><span class="nv">Index</span><span class="p">,</span> <span class="nv">Tuple</span><span class="p">,</span> <span class="nv">New</span><span class="p">).</span>

<span class="nb">make_tuple</span><span class="p">(</span><span class="nv">Length</span><span class="p">,</span> <span class="nv">Default</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">make_tuple</span><span class="p">(</span><span class="nv">Length</span><span class="p">,</span> <span class="nv">Default</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nb">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">_,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">list_to_tuple</span><span class="p">(</span><span class="nv">Acc</span><span class="p">);</span>
<span class="nb">make_tuple</span><span class="p">(</span><span class="nv">N</span><span class="p">,</span> <span class="nv">Default</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nb">make_tuple</span><span class="p">(</span><span class="nv">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nv">Default</span><span class="p">,</span> <span class="p">[</span><span class="nv">Default</span><span class="p">|</span><span class="nv">Acc</span><span class="p">]).</span>

<span class="nf">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[{</span><span class="nv">Key</span><span class="p">,_}|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">);</span>
<span class="nf">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">Acc</span><span class="p">]);</span>
<span class="nf">delete</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Acc</span><span class="p">.</span>

<span class="nf">replace</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="p">[],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[{</span><span class="nv">Key</span><span class="p">,</span><span class="nv">Value</span><span class="p">}|</span><span class="nv">Acc</span><span class="p">];</span>
<span class="nf">replace</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="p">[{</span><span class="nv">Key</span><span class="p">,_}|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">[{</span><span class="nv">Key</span><span class="p">,</span><span class="nv">Value</span><span class="p">}|</span><span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">Acc</span><span class="p">)];</span>
<span class="nf">replace</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">Acc</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">replace</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">Acc</span><span class="p">]).</span>

<span class="nf">lookup_in_list</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[])</span> <span class="o">-&gt;</span>
    <span class="n">undefined</span><span class="p">;</span>
<span class="nf">lookup_in_list</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[{</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">}|_])</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">value</span><span class="p">,</span> <span class="nv">Value</span><span class="p">};</span>
<span class="nf">lookup_in_list</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="p">[_|</span><span class="nv">T</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="n">lookup_in_list</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">T</span><span class="p">).</span>
</pre></div>
</div>
</div>
<p>该程序与程序??.4的唯一区别就在于函数<tt class="docutils literal"><span class="pre">new/1</span></tt>，我们需要向该函数传入散列表的大小。</p>
<p>程序??.4是传统散列查找程序的一个简单实现。散列表<tt class="docutils literal"><span class="pre">T</span></tt>由一个定长元组表示。为了查找项式<tt class="docutils literal"><span class="pre">Key</span></tt>对应的值，需要计算出一个介于<tt class="docutils literal"><span class="pre">1..size(T)</span></tt>之间的散列索引<tt class="docutils literal"><span class="pre">I</span></tt>。<tt class="docutils literal"><span class="pre">element(I,</span> <span class="pre">T)</span></tt>返回一个列表，包含散列索引相同的所有<tt class="docutils literal"><span class="pre">{Key,</span> <span class="pre">Value}</span></tt>键值对。在该列表中可以搜索到所需的<tt class="docutils literal"><span class="pre">{Key,</span> <span class="pre">Value}</span></tt>对。</p>
<p>向散列表中插入数据时，首先计算出<tt class="docutils literal"><span class="pre">Key</span></tt>的散列索引整数<tt class="docutils literal"><span class="pre">I</span></tt>，再向<tt class="docutils literal"><span class="pre">element(I,</span> <span class="pre">T)</span></tt>返回的列表中插入新的<tt class="docutils literal"><span class="pre">{Key,</span> <span class="pre">Value}</span></tt>对。原先与<tt class="docutils literal"><span class="pre">Key</span></tt>关联的值将被丢弃。</p>
<p><tt class="docutils literal"><span class="pre">tupleStore</span></tt>模块提供了高效的字典。为了提高访问效率散列表的大小必须大于表中所插入的元素的数目。从这种结构中进行查询非常高效，但插入就逊色些。这是因为大部分Erlang视线中BIF <tt class="docutils literal"><span class="pre">setelement(Index,</span> <span class="pre">Val,</span> <span class="pre">T)</span></tt>每次都会创建一个新的元组<tt class="docutils literal"><span class="pre">T</span></tt>。</p>
</div>
<div class="section" id="id20">
<h2>效率<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<p>最后我们来讨论一下效率。这并不是说我们认为这个主题不重要，而是因为我们相信过早关注效率问题会导致不良的程序设计。关注重点应该一直放在程序的正确性上，为了达到这个目的，我们提倡开发简练漂亮且“明显”正确的算法。</p>
<p>作为示例，我们将展示如何将低效的程序改造为高效的程序。</p>
<p>作为练习，我们从一个包含某假象公司员工信息元组的文件开始，该文件的内容为：</p>
<div class="highlight-erlang"><pre>{202191,’Micky’,’Finn’,’MNO’,’OM’,2431}.
{102347,’Harvey’,’Wallbanger’,’HAR’,’GHE’,2420}.
... 2860 lines omitted ...
{165435,’John’,’Doe’,’NKO’,’GYI’, 2564}.
{457634,’John’, ’Bull’,’HMR’,’KIO’, 5436}.</pre>
</div>
<p>我们要写一个程序来输入这些数据、将每个条目都放入字典、访问所有条目一遍，再将数据写回文件。这个程序将频繁执行，因此我们得让它尽可能地快。</p>
<div class="section" id="id21">
<h3>文件访问<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>从上述的元组文件中读入数据的最简单的方法就是使用<tt class="docutils literal"><span class="pre">file:consult(File)</span></tt>读取文件（参见附录C）——这个方法很耗时，因为每一行都会被读取和解析。一个好一点的做法是将输入文件从文本格式改为二进制格式。通过以下函数可以实现：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">reformat</span><span class="p">(</span><span class="nv">FileOfTerms</span><span class="p">,</span> <span class="nv">BinaryFile</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Terms</span><span class="p">}</span> <span class="o">=</span> <span class="nn">file</span><span class="p">:</span><span class="n">consult</span><span class="p">(</span><span class="nv">FileOfTerms</span><span class="p">),</span>
    <span class="nn">file</span><span class="p">:</span><span class="n">write_file</span><span class="p">(</span><span class="nv">BinaryFile</span><span class="p">,</span> <span class="nb">term_to_binary</span><span class="p">(</span><span class="nv">Terms</span><span class="p">)).</span>
</pre></div>
</div>
<p>要读入二进制文件并恢复原始数据，执行：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">read_terms</span><span class="p">(</span><span class="nv">BinaryFile</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nv">Binary</span><span class="p">}</span> <span class="o">=</span> <span class="nn">file</span><span class="p">:</span><span class="n">read</span><span class="p">(</span><span class="nv">BinaryFile</span><span class="p">),</span>
    <span class="nb">binary_to_term</span><span class="p">(</span><span class="nv">Binary</span><span class="p">).</span>
</pre></div>
</div>
<p>读取二进制文件并将结果转换为项式要比读取并解析一组项式要快得多，从下表便中可见一斑：</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">文本大小(bytes)</th>
<th class="head">二进制大小(bytes)</th>
<th class="head"><tt class="docutils literal"><span class="pre">file:consult</span></tt> (ms)</th>
<th class="head"><tt class="docutils literal"><span class="pre">read_terms</span></tt> (ms)</th>
<th class="head">耗时比例</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>128041</td>
<td>118123</td>
<td>42733</td>
<td>783</td>
<td>54.6</td>
</tr>
<tr><td>4541</td>
<td>4190</td>
<td>1433</td>
<td>16</td>
<td>89.6</td>
</tr>
</tbody>
</table>
<p>对于4.5K的文件，二进制文件读取要快90倍；对于128K的文件要快55倍。注意二进制文件要被文本文件小一些。</p>
</div>
<div class="section" id="id22">
<h3>字典访问<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<p>我们使用了不同的方法来构建和更新雇员字典。这些方法包括：</p>
<p><tt class="docutils literal"><span class="pre">lists</span></tt></p>
<blockquote>
<div>所有雇员记录都保存在一个列表中。在表头进行首次插入，其余更新对列表进行线性扫描。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">avl</span></tt></p>
<blockquote>
<div>采用第??节描述的AVL树插入算法。</div></blockquote>
<p><tt class="docutils literal"><span class="pre">hash</span></tt></p>
<blockquote>
<div>采用程序9.4的散列算法。</div></blockquote>
<p>为了检验不同方法的效率，我们对我们的每一条雇员数据都进行一次插入和查找，得到以下的计时结果：</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">条目数</th>
<th class="head">AVL插入</th>
<th class="head">AVL查找</th>
<th class="head">列表插入</th>
<th class="head">列表查找</th>
<th class="head">散列插入</th>
<th class="head">散列查找</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>25</td>
<td>5.32</td>
<td>0.00</td>
<td>0.00</td>
<td>0.64</td>
<td>1.32</td>
<td>0.00</td>
</tr>
<tr><td>50</td>
<td>1.32</td>
<td>0.32</td>
<td>0.00</td>
<td>1.00</td>
<td>0.32</td>
<td>0.00</td>
</tr>
<tr><td>100</td>
<td>2.00</td>
<td>0.50</td>
<td>0.00</td>
<td>1.50</td>
<td>0.33</td>
<td>0.16</td>
</tr>
<tr><td>200</td>
<td>9.91</td>
<td>0.50</td>
<td>0.00</td>
<td>3.00</td>
<td>2.08</td>
<td>0.17</td>
</tr>
<tr><td>400</td>
<td>28.29</td>
<td>0.46</td>
<td>0.04</td>
<td>5.96</td>
<td>4.25</td>
<td>0.09</td>
</tr>
<tr><td>800</td>
<td>301.38</td>
<td>0.54</td>
<td>0.02</td>
<td>11.98</td>
<td>1.77</td>
<td>0.15</td>
</tr>
<tr><td>1600</td>
<td>1060.44</td>
<td>0.61</td>
<td>0.02</td>
<td>24.20</td>
<td>4.05</td>
<td>0.14</td>
</tr>
</tbody>
</table>
<p>上表中每次插入或查询的时间单位都是毫秒。我们看到对于大小超过800的数据表，散列表的查询效率是最高的。</p>
<p>上面我们看到使用二进制文件和散列查询算法要比使用<tt class="docutils literal"><span class="pre">file:consult</span></tt>和简单列表查询方法快六千倍。和传统命令式语言一样，决定程序效率的最重要因素还是良好的算法设计。</p>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[1]</a></td><td>当然，要除去服务器用于存储本地数据结构的空间。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[2]</a></td><td>非扁平列表就是不含有子列表的列表。（译者注：也就是说当<tt class="docutils literal"><span class="pre">Data</span></tt>是一个整数列表时，既可以是<tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>也可以是<tt class="docutils literal"><span class="pre">[1,[2,3]]</span></tt>，在这里二者是等价的。）</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">第9章 杂项</a><ul>
<li><a class="reference internal" href="#id4">末尾调用优化</a><ul>
<li><a class="reference internal" href="#id5">尾递归</a></li>
<li><a class="reference internal" href="#id6">末尾调用优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">引用</a></li>
<li><a class="reference internal" href="#id9">代码替换</a><ul>
<li><a class="reference internal" href="#id10">代码替换实例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">端口</a><ul>
<li><a class="reference internal" href="#id13">打开端口</a></li>
<li><a class="reference internal" href="#erlang">Erlang进程眼中的端口</a></li>
<li><a class="reference internal" href="#id14">外部进程眼中的端口</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">二进制类型</a></li>
<li><a class="reference internal" href="#id16">进程字典</a></li>
<li><a class="reference internal" href="#id17">网络内核</a><ul>
<li><a class="reference internal" href="#id18">认证</a></li>
<li><a class="reference internal" href="#net-kernel">net_kernel消息</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">散列</a></li>
<li><a class="reference internal" href="#id20">效率</a><ul>
<li><a class="reference internal" href="#id21">文件访问</a></li>
<li><a class="reference internal" href="#id22">字典访问</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="part-i_chapter-8.html"
                        title="上一章">第8章 编写健壮的应用程序</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="part-i_appendix-a.html"
                        title="下一章">附录A Erlang 语法参考</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_appendix-a.html" title="附录A Erlang 语法参考"
             >下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-8.html" title="第8章 编写健壮的应用程序"
             >上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" >第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2009, CPiE-CN志愿译者团队.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>