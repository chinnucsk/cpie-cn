
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第2章 串行编程 &mdash; Erlang并发编程</title>
    <link rel="stylesheet" href="_static/nature-ext.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Erlang并发编程" href="index.html" />
    <link rel="up" title="第 I 部分 编程" href="part-i_index.html" />
    <link rel="next" title="第3章 列表编程" href="part-i_chapter-3.html" />
    <link rel="prev" title="第1章 Erlang教程" href="part-i_chapter-1.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-3.html" title="第3章 列表编程"
             accesskey="N">下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-1.html" title="第1章 Erlang教程"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" accesskey="U">第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>第2章 串行编程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">翻译:</th><td class="field-body">连城</td>
</tr>
</tbody>
</table>
<p>本章介绍用于编写串行Erlang程序的概念。我们首先讨论变量赋值的基本机制和如何实现控制流程。为此，我们要先了解一下<strong>项式</strong>、<strong>模式</strong>和<strong>模式匹配</strong>。</p>
<div class="section" id="id2">
<h2>项式<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>Erlang中以下数据类型<a class="footnote-reference" href="#id35" id="id3">[1]</a>被称为<strong>项式</strong>：</p>
<blockquote>
<div><ul class="simple">
<li><strong>常量</strong>类型<ul>
<li>数值<ul>
<li>整数，用于存储自然数</li>
<li>浮点数，用于存储实数</li>
</ul>
</li>
<li>原子式</li>
<li>Pid（进程标识符process identifier的缩写），用于存储进程标识</li>
<li>引用，用于存储系统范围内唯一的引用</li>
</ul>
</li>
<li><strong>复合</strong>数据类型<ul>
<li>元组，用于存储固定数目的多个项式</li>
<li>列表，用于存储可变数目的多个项式</li>
</ul>
</li>
</ul>
</div></blockquote>
<div class="section" id="id4">
<h3>数值<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>以下实例都属于数值：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="mi">123</span> <span class="o">-</span><span class="mi">34567</span> <span class="mi">12</span><span class="p">.</span><span class="mi">345</span> <span class="o">-</span><span class="mi">27</span><span class="p">.</span><span class="mi">45</span><span class="n">e</span><span class="o">-</span><span class="mi">05</span>
</pre></div>
</div>
<p>整数精度与实现相关，但任何Erlang系统都应保证至少24位的整数精度。</p>
<p><tt class="docutils literal"><span class="pre">$&lt;Char&gt;</span></tt>标记表示字符<tt class="docutils literal"><span class="pre">Char</span></tt>对应的ASCII值，如<tt class="docutils literal"><span class="pre">$A</span></tt>表示整数65。</p>
<p>不以10为基数的整数可写作<tt class="docutils literal"><span class="pre">&lt;Base&gt;#&lt;Value&gt;</span></tt>，如16#ffff表示十进制整数65535。<tt class="docutils literal"><span class="pre">Base</span></tt>的取值范围为2 .. 16。</p>
<p>浮点数以传统方式书写。</p>
</div>
<div class="section" id="id5">
<h3>原子式<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>原子式是有名称的常量。例如在某个用于日历计算的程序中可使用<tt class="docutils literal"><span class="pre">monday</span></tt>、<tt class="docutils literal"><span class="pre">tuesday</span></tt>等等表示一星期中的各天。原子式用于增强程序的可读性。</p>
<p>一些原子式实例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="n">friday</span> <span class="n">unquoted_atoms_cannot_contain_blanks</span>
<span class="n">&#39;A quoted atom which contains several blanks&#39;</span>
<span class="n">&#39;hello \n my friend&#39;</span>
</pre></div>
</div>
<p>原子式以小写字母（<tt class="docutils literal"><span class="pre">a..z</span></tt>）开头，以非字母数字字符结尾——否则就必须用引号括起来。</p>
<p>通过将原子式以引号括起来，原子式中便可以出现任意字符。原子式总是以可被 Erlang 读取程序读入的格式输出。原子式引号内的字符遵循如下规范：</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">字符</th>
<th class="head">含义</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td>
<td>退格符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\d</span></tt></td>
<td>删除符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td>
<td>转义符（ESC）</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td>
<td>换页符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt></td>
<td>换行符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt></td>
<td>回车符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td>
<td>制表符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td>
<td>垂直制表符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td>
<td>反斜线</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\^A</span> <span class="pre">..</span> <span class="pre">\^Z</span></tt></td>
<td>control A到control Z（即0 .. 26）</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td>
<td>单引号</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td>
<td>双引号</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">\OOO</span></tt></td>
<td>使用八进制格式<tt class="docutils literal"><span class="pre">OOO</span></tt>表示的字符</td>
</tr>
</tbody>
</table>
<p>在引号括起来的原子式中如果包含字符序列<tt class="docutils literal"><span class="pre">\C</span></tt>，其中<tt class="docutils literal"><span class="pre">C</span></tt>的ASCII值小于32，则表示<tt class="docutils literal"><span class="pre">\C</span></tt>的这部分源码被忽略（这样我们在编程时就可以使用一个反斜线加换行符来将长原子式分隔为几行）。</p>
</div>
<div class="section" id="id6">
<h3>元组<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>以花括号包围的一系列以逗号分隔的项式称为<strong>元组</strong>。元组用于存储固定数目个项式。它们与传统编程语言中的<strong>结构</strong>或<strong>记录</strong>类似。</p>
<p>元组<tt class="docutils literal"><span class="pre">{E1,E2,...,En}</span></tt>，其中<tt class="docutils literal"><span class="pre">n</span></tt>大于0，称为<strong>大小</strong>为<tt class="docutils literal"><span class="pre">n</span></tt>的元组。元组中的单个项式称为<strong>元素</strong>。</p>
<p>以下是一些元组实例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">&#39;hello&#39;</span><span class="p">}</span>
<span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="p">{</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">}}}</span>
<span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>列表<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>以方括号包围的一系列以逗号分隔的项式成为<strong>列表</strong>。列表用于存储可变数目个项式。</p>
<p>对于列表<tt class="docutils literal"><span class="pre">[E1,E2,...En]</span></tt>，其中<tt class="docutils literal"><span class="pre">n</span></tt> &gt;= 0 ，称其长度为<tt class="docutils literal"><span class="pre">n</span></tt>。</p>
<p>以下是一些元组实例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">abc</span><span class="p">,</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">&#39;foo bar&#39;</span><span class="p">]</span>
<span class="p">[]</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
<span class="s">&quot;abcd&quot;</span>
</pre></div>
</div>
<p>被我们称之为字符串的<tt class="docutils literal"><span class="pre">&quot;...&quot;</span></tt>标记，实际上是引号中各个字符组成的列表的ASCII简写形式。因此<tt class="docutils literal"><span class="pre">&quot;abc&quot;</span></tt>对应于<tt class="docutils literal"><span class="pre">[97,98,99]</span></tt>。在原子式中使用的转义规则在字符串中通用。</p>
<p>在对列表进行处理时，往往需要一种方便的手段来引用列表的第一个元素以及除掉第一个元素以外列表的剩余部分。方便起见，我们将列表的第一个元素称为<strong>头部</strong>，将剩余部分称为 <em>尾部</em> 。</p>
<p>我们使用<tt class="docutils literal"><span class="pre">[E1,E2,E3,...,En|Variable]</span></tt>来标记一个前<tt class="docutils literal"><span class="pre">n</span></tt>个元素分别为<tt class="docutils literal"><span class="pre">E1,E2,E3,...,En</span></tt>而剩余部分记为<tt class="docutils literal"><span class="pre">Variable</span></tt>的列表。</p>
<p>注意“<tt class="docutils literal"><span class="pre">|</span></tt>”之后的项式不一定要是列表，它可以是任意一个合法的Erlang项式。最后一个尾部为项式<tt class="docutils literal"><span class="pre">[]</span></tt>的列表称为<strong>真</strong>列表或<strong>格式良好</strong>的列表——大多数（尽管不是全部）Erlang程序都是被编写来处理格式良好的列表的。</p>
</div>
</div>
<div class="section" id="id8">
<h2>模式匹配<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>模式与项式有着相同的结构，但它们还可以包含变量。变量名都以大写字母开头。</p>
<p>模式示例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">34</span><span class="p">|{</span><span class="n">a</span><span class="p">}]}</span>
<span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">,</span> <span class="mi">23</span><span class="p">}</span>
<span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="nv">X_1</span><span class="p">},</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">My_cats_age</span><span class="p">}</span>
<span class="p">[]</span>
</pre></div>
</div>
<p>以上的<tt class="docutils literal"><span class="pre">A</span></tt>、<tt class="docutils literal"><span class="pre">B</span></tt>、<tt class="docutils literal"><span class="pre">X_1</span></tt>和<tt class="docutils literal"><span class="pre">My_cats_age</span></tt>都是变量。</p>
<p>模式匹配为变量赋值提供了基本的机制。被赋值后，变量便<strong>被绑定</strong>——否则便是<strong>未绑定</strong>变量。给变量赋值的动作称作“绑定”。变量一旦被绑定便不可更改。这种变量属性被称为<strong>一次性绑定</strong>或<strong>单次赋值</strong>。这种属性与传统命令式语言的<strong>破坏性赋值</strong><a class="footnote-reference" href="#id36" id="id9">[2]</a>相反。</p>
<p>如果一个<strong>模式</strong>与一个<strong>项式</strong>在结构上同构，且在模式中任一位置出现的原子数据类型也都在项式的相应位置上出现，则称他们它们相互<strong>匹配</strong>。如果模式中包含未绑定变量，则该变量在匹配过程中将被绑定到项式中相应的元素。如果在模式中<strong>相同的</strong>变量多次出现，则项式中对应位置的元素也必须相同。</p>
<p>模式匹配在以下情况下发生：</p>
<ul class="simple">
<li>计算形如<tt class="docutils literal"><span class="pre">Lhs</span> <span class="pre">=</span> <span class="pre">Rhs</span></tt>的表达式时</li>
<li>调用函数时</li>
<li>在<tt class="docutils literal"><span class="pre">case</span></tt>和<tt class="docutils literal"><span class="pre">receive</span></tt>原语中对指定模式进行匹配时</li>
</ul>
<div class="section" id="pattern-expression">
<h3><tt class="docutils literal"><span class="pre">Pattern</span> <span class="pre">=</span> <span class="pre">Expression</span></tt><a class="headerlink" href="#pattern-expression" title="永久链接至标题">¶</a></h3>
<p>表达式<tt class="docutils literal"><span class="pre">Pattern</span> <span class="pre">=</span> <span class="pre">Expression</span></tt>将致使<tt class="docutils literal"><span class="pre">Expression</span></tt>被求值，并将其结果与<tt class="docutils literal"><span class="pre">Pattern</span></tt>进行匹配。匹配要么成功要么失败。若匹配成功则<tt class="docutils literal"><span class="pre">Pattern</span></tt>中的所有（未绑定）变量都将被绑定。</p>
<p>以下我们将假设模式匹配总是<strong>成功</strong>。对<strong>失败</strong>的处理将在第??章详细讨论。</p>
<p>示例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">A</span><span class="p">,</span> <span class="nv">B</span><span class="p">}</span> <span class="o">=</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="n">apple</span><span class="p">}</span>
</pre></div>
</div>
<p>匹配成功后建立绑定关系<tt class="docutils literal"><span class="pre">A</span></tt>→<tt class="docutils literal"><span class="pre">12</span></tt><a class="footnote-reference" href="#id37" id="id10">[3]</a>和<tt class="docutils literal"><span class="pre">B</span></tt>→<tt class="docutils literal"><span class="pre">apple</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="nv">C</span><span class="p">,</span> <span class="p">[</span><span class="nv">Head</span><span class="p">|</span><span class="nv">Tail</span><span class="p">]}</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">222</span><span class="p">,</span> <span class="n">man</span><span class="p">},</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]}</span>
</pre></div>
</div>
<p>匹配成功后建立绑定关系<tt class="docutils literal"><span class="pre">C</span></tt>→<tt class="docutils literal"><span class="pre">{222,</span> <span class="pre">man}</span></tt>、<tt class="docutils literal"><span class="pre">Head</span></tt>→<tt class="docutils literal"><span class="pre">a</span></tt>和<tt class="docutils literal"><span class="pre">Tail</span></tt>→<tt class="docutils literal"><span class="pre">[b,</span> <span class="pre">c]</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">[{</span><span class="n">person</span><span class="p">,</span> <span class="nv">Name</span><span class="p">,</span> <span class="nv">Age</span><span class="p">,</span> <span class="p">_}|</span><span class="nv">T</span><span class="p">]</span> <span class="o">=</span>
        <span class="p">[{</span><span class="n">person</span><span class="p">,</span> <span class="n">fred</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="n">male</span><span class="p">},</span>
         <span class="p">{</span><span class="n">person</span><span class="p">,</span> <span class="n">susan</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="n">female</span><span class="p">},</span> <span class="p">...]</span>
</pre></div>
</div>
<p>匹配成功后建立绑定关系<tt class="docutils literal"><span class="pre">T</span></tt>→<tt class="docutils literal"><span class="pre">[{person,</span> <span class="pre">susan,</span> <span class="pre">19,</span> <span class="pre">female},</span> <span class="pre">...]}</span></tt>、<tt class="docutils literal"><span class="pre">Name</span></tt>→<tt class="docutils literal"><span class="pre">fred</span></tt>和<tt class="docutils literal"><span class="pre">Age</span></tt>→<tt class="docutils literal"><span class="pre">22</span></tt>。在最后一个例子中我们利用了写作“<tt class="docutils literal"><span class="pre">_</span></tt>”的<strong>匿名</strong>变量——在语法上需要一个变量出现，但我们又不关心该变量的值的时候便可以使用匿名变量。</p>
<p>当一个变量在一个模式中多次出现时，只有被匹配的对应元素的值都相同时匹配才会成功。因此，举例来说，<tt class="docutils literal"><span class="pre">{A,</span> <span class="pre">foo,</span> <span class="pre">A}</span> <span class="pre">=</span> <span class="pre">{123,</span> <span class="pre">foo,</span> <span class="pre">123}</span></tt>将成功匹配，并将<tt class="docutils literal"><span class="pre">A</span></tt>绑定到<tt class="docutils literal"><span class="pre">123</span></tt>，然而<tt class="docutils literal"><span class="pre">{A,</span> <span class="pre">foo,</span> <span class="pre">A}</span> <span class="pre">=</span> <span class="pre">{123,</span> <span class="pre">foo,</span> <span class="pre">abc}</span></tt>就会失败，因为我们不能将<tt class="docutils literal"><span class="pre">A</span></tt>同时绑定到<tt class="docutils literal"><span class="pre">123</span></tt><strong>和</strong><tt class="docutils literal"><span class="pre">abc</span></tt>。</p>
<p>“<tt class="docutils literal"><span class="pre">=</span></tt>”是一个右结合的中缀运算符。因此<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">D</span></tt>将被解析为<tt class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">(B</span> <span class="pre">=</span> <span class="pre">(C</span> <span class="pre">=</span> <span class="pre">D))</span></tt>。这种用法可能只有在<tt class="docutils literal"><span class="pre">{A,</span> <span class="pre">B}</span> <span class="pre">=</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">...</span></tt>这样的构造中才有用，这时我们可以同时获悉表达式的值及其组成部分。表达式<tt class="docutils literal"><span class="pre">Lhs</span> <span class="pre">=</span> <span class="pre">Rhs</span></tt>的值被定义为<tt class="docutils literal"><span class="pre">Rhs</span></tt>。</p>
</div>
<div class="section" id="id11">
<h3>函数调用中的模式匹配<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<p>Erlang通过模式匹配来提供选择和控制流程。例如，程序2.1定义了一个函数<tt class="docutils literal"><span class="pre">classify_day/1</span></tt>，当调用参数为<tt class="docutils literal"><span class="pre">saturday</span></tt>或<tt class="docutils literal"><span class="pre">sunday</span></tt>时返回<tt class="docutils literal"><span class="pre">weekEnd</span></tt>，否则返回<tt class="docutils literal"><span class="pre">weekDay</span></tt> 。</p>
<div class="topic">
<p class="topic-title first">程序 2.1</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">dates</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">classify_day</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">classify_day</span><span class="p">(</span><span class="n">saturday</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">weekEnd</span><span class="p">;</span>
<span class="nf">classify_day</span><span class="p">(</span><span class="n">sunday</span><span class="p">)</span>   <span class="o">-&gt;</span> <span class="n">weekEnd</span><span class="p">;</span>
<span class="nf">classify_day</span><span class="p">(_)</span>        <span class="o">-&gt;</span> <span class="n">weekDay</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>进行函数求值时，会将函数的参数与函数定义中出现的模式一一进行匹配。一旦发现一个成功的匹配，“<tt class="docutils literal"><span class="pre">-&gt;</span></tt>”之后的符号便被求值，因此：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nn">dates</span><span class="p">:</span><span class="n">classify_day</span><span class="p">(</span><span class="n">saturday</span><span class="p">).</span>
<span class="n">weekEnd</span>
<span class="o">&gt;</span> <span class="nn">dates</span><span class="p">:</span><span class="n">classify_day</span><span class="p">(</span><span class="n">friday</span><span class="p">).</span>
<span class="n">weekDay</span>
</pre></div>
</div>
<p>如果所有的子句都不匹配，则函数调用<strong>失败</strong>（失败将引发第??章描述的错误捕捉机制）。</p>
<p>当执行流程进入一个函数的某个子句时，描述该子句的模式所包含的变量将被绑定。因此，举例来说，对程序1.3的<tt class="docutils literal"><span class="pre">math3:area({square,</span> <span class="pre">5})</span></tt>进行求值将致使变量<tt class="docutils literal"><span class="pre">Side</span></tt>被绑定到<tt class="docutils literal"><span class="pre">5</span></tt>。</p>
</div>
</div>
<div class="section" id="id12">
<h2>表达式求值<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<p>表达式具备与模式相同的语法，同时表达式还可以包含函数调用或传统的中序算术表达式。函数调用的写法很传统，如：<tt class="docutils literal"><span class="pre">area:triangle(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></tt>便代表以参数<tt class="docutils literal"><span class="pre">A</span></tt>、<tt class="docutils literal"><span class="pre">B</span></tt>和<tt class="docutils literal"><span class="pre">C</span></tt>调用函数<tt class="docutils literal"><span class="pre">area:triangle</span></tt>。</p>
<p>Erlang 表达式的求值机制如下。</p>
<p>对项式求值得到其本身：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="mi">222</span><span class="p">.</span>
<span class="mi">222</span>
<span class="o">&gt;</span> <span class="n">abc</span><span class="p">.</span>
<span class="n">abc</span>
<span class="o">&gt;</span> <span class="mi">3</span><span class="p">.</span><span class="mi">1415926</span><span class="p">.</span>
<span class="mi">3</span><span class="p">.</span><span class="mi">14159</span>
<span class="o">&gt;</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="mi">12</span><span class="p">,[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">|</span><span class="n">d</span><span class="p">]}.</span>
<span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="mi">12</span><span class="p">,[</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">|</span><span class="n">d</span><span class="p">]}</span>
<span class="o">&gt;</span> <span class="p">{{},[{}],{</span><span class="n">a</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="n">&#39;hello world&#39;</span><span class="p">}}.</span>
<span class="p">{{},[{}],{</span><span class="n">a</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="n">&#39;hello world&#39;</span><span class="p">}}</span>
</pre></div>
</div>
<p>浮点数的输出格式可能与它们的输入格式不完全一致。当表达式与项式同构且表达式中的函数调用都已求值完毕时，表达式将被求值为项式。应用一个函数时其参数首先被求值。</p>
<p>求值过程可以被认为是一个将表达式归结为基础项式的函数：</p>
<pre class="literal-block">
ε(X) when Constant(X)→X
ε({t1,t2,...,tn})→{ε(t1),ε(t2),...,ε(tn)}
ε([t1,t2,...,tn])→[ε(t1),ε(t2),...,ε(tn)]
ε(functionName(t1,t2,...,tn)→
    APPLY(functionName,[ε(t1),ε(t2),...,ε(tn)])
</pre>
<p>其中<tt class="docutils literal"><span class="pre">APPLY</span></tt>表示一个将参数应用到函数的函数。</p>
<div class="section" id="id13">
<h3>函数求值<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h3>
<p>函数调用的写法如以下实例所示：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nb">length</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]).</span>
<span class="mi">3</span>
<span class="o">&gt;</span> <span class="nn">lists</span><span class="p">:</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]).</span>
<span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="nn">math</span><span class="p">:</span><span class="n">pi</span><span class="p">().</span>
<span class="mi">3</span><span class="p">.</span><span class="mi">14159</span>
</pre></div>
</div>
<p>带冒号形式的函数将在和模块相关的章节中解释。调用没有参数的函数必须加上一对空的小括号（以此与原子式相区别）。</p>
</div>
<div class="section" id="id14">
<h3>求值顺序<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>函数参数的求值顺序是不确定的。例如，<tt class="docutils literal"><span class="pre">f({a},b(),g(a,h(b),{f,X}))</span></tt>表示一个函数调用。对函数<tt class="docutils literal"><span class="pre">f</span></tt>的调用有三个参数：<tt class="docutils literal"><span class="pre">{a}</span></tt>、<tt class="docutils literal"><span class="pre">b()</span></tt>和<tt class="docutils literal"><span class="pre">g(a,h(b),{f,X})</span></tt>。第一个参数是一个只包含一个原子项<tt class="docutils literal"><span class="pre">a</span></tt>的元组。第二个参数是一个函数调用<tt class="docutils literal"><span class="pre">b()</span></tt>。第三个参数是函数调用<tt class="docutils literal"><span class="pre">g(a,h(b),{f,X})</span></tt>。在对<tt class="docutils literal"><span class="pre">f/3</span></tt>求值时，对<tt class="docutils literal"><span class="pre">b/0</span></tt>和<tt class="docutils literal"><span class="pre">g/3</span></tt>的求值顺序是不确定的，不过<tt class="docutils literal"><span class="pre">h(b)</span></tt>在<tt class="docutils literal"><span class="pre">g/3</span></tt>被求值。对<tt class="docutils literal"><span class="pre">b()</span></tt>和<tt class="docutils literal"><span class="pre">h(b)</span></tt>的求值顺序也是不确定的。</p>
<p>在对形如<tt class="docutils literal"><span class="pre">[f(a),</span> <span class="pre">g(b),</span> <span class="pre">h(k)]</span></tt>的表达式进行求值时，<tt class="docutils literal"><span class="pre">f(a)</span></tt>、<tt class="docutils literal"><span class="pre">g(b)</span></tt>和<tt class="docutils literal"><span class="pre">h(k)</span></tt>的求值顺序是不确定的。</p>
<p>如果<tt class="docutils literal"><span class="pre">f(a)</span></tt>、<tt class="docutils literal"><span class="pre">g(b)</span></tt>和<tt class="docutils literal"><span class="pre">h(k)</span></tt>的求值过程没有副作用（即不发送消息、不创建进程等等），则<tt class="docutils literal"><span class="pre">[f(a),</span> <span class="pre">g(b),</span> <span class="pre">h(k)]</span></tt>的<strong>值</strong>与求值顺序无关<a class="footnote-reference" href="#id38" id="id15">[4]</a>。这种属性叫作<strong>引用透明性</strong><a class="footnote-reference" href="#id39" id="id16">[5]</a>。</p>
</div>
<div class="section" id="id17">
<h3>应用<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>BIF <tt class="docutils literal"><span class="pre">apply(Mod,</span> <span class="pre">Func,</span> <span class="pre">ArgList)</span></tt>和<tt class="docutils literal"><span class="pre">apply({Mod,</span> <span class="pre">Func},</span> <span class="pre">ArgList)</span></tt>用于将模块<tt class="docutils literal"><span class="pre">Mod</span></tt>中的函数<tt class="docutils literal"><span class="pre">Func</span></tt>应用到参数列表<tt class="docutils literal"><span class="pre">ArgList</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="o">&gt;</span> <span class="nb">apply</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">classify_day</span><span class="p">,</span> <span class="p">[</span><span class="n">monday</span><span class="p">]).</span>
<span class="n">weekDay</span>
<span class="o">&gt;</span> <span class="nb">apply</span><span class="p">(</span><span class="n">math</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">]).</span>
<span class="mi">2</span><span class="p">.</span><span class="mi">0</span>
<span class="o">&gt;</span> <span class="nb">apply</span><span class="p">({</span><span class="n">erlang</span><span class="p">,</span> <span class="nb">atom_to_list</span><span class="p">},</span> <span class="p">[</span><span class="n">abc</span><span class="p">]).</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">]</span>
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">apply</span></tt>对BIF进行求值时，可以使用<tt class="docutils literal"><span class="pre">erlang</span></tt>作为模块名。</p>
</div>
</div>
<div class="section" id="id18">
<h2>模块系统<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h2>
<p>Erlang具备一套模块系统以便我们将大型程序切分为一组模块。每个模块都有自己的名称空间；这样我们就可以在不同的模块中自由地使用相同的函数名而不会有任何冲突。</p>
<p>模块系统以对给定模块中函数的可见性进行限制的方式来工作的。函数的调用方式取决于模块名、函数名以及函数名是否在模块的导入或导出声明中出现。</p>
<div class="topic">
<p class="topic-title first">程序 2.2</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">lists1</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">reverse</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">reverse</span><span class="p">(</span><span class="nv">L</span><span class="p">,</span> <span class="p">[]).</span>

<span class="nf">reverse</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">reverse</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="p">[</span><span class="nv">H</span><span class="p">|</span><span class="nv">L</span><span class="p">]);</span>
<span class="nf">reverse</span><span class="p">([],</span> <span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="nv">L</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>程序2.2定义了一个颠倒列表元素顺序的函数<tt class="docutils literal"><span class="pre">reverse/1</span></tt>。<tt class="docutils literal"><span class="pre">reverse/1</span></tt>是该模块中<strong>唯一</strong>可以从该模块之外被调用的函数。需要从模块外部调用的函数必须出现在模块的导出声明中。</p>
<p>该模块中定义的其他函数，<tt class="docutils literal"><span class="pre">reverse/2</span></tt>，仅可供模块<strong>内部</strong>使用。注意<tt class="docutils literal"><span class="pre">reverse/1</span></tt>和<tt class="docutils literal"><span class="pre">reverse/2</span></tt>是完全不同的函数。在Erlang中，名字相同但参数数目不同的两个函数是完全不同的函数。</p>
<div class="section" id="id19">
<h3>模块间调用<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<p>从其他模块中调用函数的方法有两种：</p>
<div class="topic">
<p class="topic-title first">程序 2.3</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">sort1</span><span class="p">).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">reverse_sort</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">reverse_sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="nn">lists1</span><span class="p">:</span><span class="n">reverse</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)).</span>
<span class="nf">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="nn">lists</span><span class="p">:</span><span class="n">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
</div>
<p><tt class="docutils literal"><span class="pre">reverse/1</span></tt>以<strong>完全限定名称</strong>被调用。</p>
<p>你还可以借助<tt class="docutils literal"><span class="pre">import</span></tt>声明使用<strong>隐式限定函数名</strong>，如程序2.4所示。</p>
<div class="topic">
<p class="topic-title first">程序 2.4</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">sort2</span><span class="p">).</span>
<span class="p">-</span><span class="ni">import</span><span class="p">(</span><span class="n">lists1</span><span class="p">,</span> <span class="p">[</span><span class="n">reverse</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>
<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">reverse_sort</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="n">sort</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="nf">reverse_sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)).</span>
<span class="nf">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="nn">lists</span><span class="p">:</span><span class="n">sort</span><span class="p">(</span><span class="nv">L</span><span class="p">).</span>
</pre></div>
</div>
</div>
<p>两种形式都是为了解决二义性。比如，当两个不同的模块导出了重名的函数，则必须显式限定函数名。</p>
</div>
</div>
<div class="section" id="id20">
<h2>函数定义<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h2>
<p>以下章节更详细地描述了Erlang函数的语法。首先我来给函数的各个语法元素命名。接着将详细描述这些元素。</p>
<div class="section" id="id21">
<h3>术语<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<p>考虑以下模块：<a class="footnote-reference" href="#id43" id="id22">[*]</a></p>
<div class="topic">
<p class="topic-title first">程序 2.5</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">lists2</span><span class="p">).</span>

<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">flat_length</span><span class="o">/</span><span class="mi">1</span><span class="p">]).</span>

<span class="c">%% flat_length(List)</span>
<span class="c">%%  Calculate the length of a list of lists.</span>

<span class="nf">flat_length</span><span class="p">(</span><span class="nv">List</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">flat_length</span><span class="p">(</span><span class="nv">List</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span>

<span class="nf">flat_length</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="n">list</span><span class="p">(</span><span class="nv">H</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">flat_length</span><span class="p">(</span><span class="nv">H</span><span class="p">,</span> <span class="n">flat_length</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">N</span><span class="p">));</span>
<span class="nf">flat_length</span><span class="p">([</span><span class="nv">H</span><span class="p">|</span><span class="nv">T</span><span class="p">],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="n">flat_length</span><span class="p">(</span><span class="nv">T</span><span class="p">,</span> <span class="nv">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="nf">flat_length</span><span class="p">([],</span> <span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">N</span><span class="p">.</span>
</pre></div>
</div>
</div>
<p>以“<tt class="docutils literal"><span class="pre">%</span></tt>”打头的是注释。注释可以从一行的任意位置开始，一直持续到行末。</p>
<p>第1行包含<strong>模块</strong>声明。该行必须出现在任何其他声明或代码之前。</p>
<p>第1行和第3行开头的“<tt class="docutils literal"><span class="pre">-</span></tt>”称为<strong>属性前缀</strong>。<tt class="docutils literal"><span class="pre">module(list2)</span></tt>便是属性的一个例子。</p>
<p>第2、第4等行是空行——连续的单个或多个空白符、空行、制表符、换行符等，都被当作单个空白符处理。</p>
<p>第3行声明了一个具有一个参数的函数<tt class="docutils literal"><span class="pre">flag_length</span></tt>，该行意味着该函数存在于模块中并会被从模块中导出。</p>
<p>第5、6行是注释。</p>
<p>第8、9行包含了函数<tt class="docutils literal"><span class="pre">flat_length/1</span></tt>的定义。它由单个<strong>子句</strong>组成。</p>
<p>表达式<tt class="docutils literal"><span class="pre">flat_length(List)</span></tt>称为子句的<strong>头部</strong>。“<tt class="docutils literal"><span class="pre">-&gt;</span></tt>”之后的部分为子句的<strong>主体</strong>。</p>
<p>第11至16行函数<tt class="docutils literal"><span class="pre">flat_length/2</span></tt>的定义——该函数包含三个子句；子句间以分号“<tt class="docutils literal"><span class="pre">;</span></tt>”分隔，在最后的结尾处以“<tt class="docutils literal"><span class="pre">.</span></tt>”结尾。</p>
<p>第11行中<tt class="docutils literal"><span class="pre">flat_length/2</span></tt>的第一个参数为列表<tt class="docutils literal"><span class="pre">[H|T]</span></tt>。<tt class="docutils literal"><span class="pre">H</span></tt>表示列表的<strong>头部</strong>，<tt class="docutils literal"><span class="pre">T</span></tt>代表列表的<strong>尾部</strong>。在关键字<tt class="docutils literal"><span class="pre">when</span></tt>和箭头“<tt class="docutils literal"><span class="pre">-&gt;</span></tt>”之间的表达式<tt class="docutils literal"><span class="pre">list(H)</span></tt>称作保护式。只有在参数与函数头部的模式相匹配且保护式断言成立时，函数体才会被求值。</p>
<p><tt class="docutils literal"><span class="pre">flat_length/2</span></tt>的第一个子句称为<strong>保护子句</strong>；其他的子句称为<strong>无保护子句</strong>。</p>
<p><tt class="docutils literal"><span class="pre">flat_length/2</span></tt>是一个<strong>局部函数</strong>——即不可从模块外部被调用（因为它没有出现在<tt class="docutils literal"><span class="pre">export</span></tt>属性中）。</p>
<p>模块<tt class="docutils literal"><span class="pre">lists2</span></tt>包含了函数<tt class="docutils literal"><span class="pre">flat_length/1</span></tt><strong>和</strong><tt class="docutils literal"><span class="pre">flat_length/2</span></tt>的定义。它们代表<strong>两个完全不同的函数</strong>——这与C或Pascal等语言不通，在这些语言中一个函数名只能出现一次，且只能有<strong>固定</strong>个数的参数。</p>
</div>
<div class="section" id="id23">
<h3>子句<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<p>每个函数都由一组<strong>子句</strong>组成。子句间以分号“<tt class="docutils literal"><span class="pre">;</span></tt>”分隔。每个子句都包含一个子句头部、一个可选的保护式和子句主体。下面将详细解释。</p>
</div>
<div class="section" id="id24">
<h3>子句头部<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>子句的头部包含一个函数名和一组以逗号分隔的参数。每个参数都是一个合法的模式。</p>
<p>当函数调用发生时，将会按顺序对函数定义中的子句头部依次进行匹配。</p>
</div>
<div class="section" id="id25">
<h3>子句保护式<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<p>保护式是子句被选中前必须要满足的条件。</p>
<p>保护式可以是一个简单的断言或是一组由逗号分隔的简单断言。一个简单断言可以是一个算数比较、项式比较，或是一个系统预定义的断言函数。保护式可以看作是模式匹配的一种扩展。用户自定义的函数不能用在保护式内。</p>
<p>对保护式求值时所有的断言都将被求值。若所有断言都为真，则保护式成立，否则就失败。保护式中各个断言的求值顺序是不确定的。</p>
<p>如果保护式成立，则会对子句的主体进行求值。如果保护式失败，则尝试下一个候选子句。</p>
<p>一旦子句的头部和保护式都匹配成功，系统将<strong>指定</strong>这条子句并对其主体求值。</p>
<p>我们可以写一个保护式版本的<tt class="docutils literal"><span class="pre">factorial</span></tt>。</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>注意对于以上示例，我们可以调换子句的顺序，即：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">.</span>
</pre></div>
</div>
<p>在这个示例中子句首部模式与保护式的组合可以唯一确定一个正确的子句。</p>
</div>
<div class="section" id="id26">
<h3>保护式断言<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>保护式断言的完整集合如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">保护式</th>
<th class="head">成立条件</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">atom(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个原子式</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">constant(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>不是列表或元组</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">float(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个浮点数</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">integer(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个整数</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">list(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个列表或 <tt class="docutils literal"><span class="pre">[]</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">number</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个整数或浮点数</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">pid(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个进程标识符</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">port(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个端口</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">reference(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个引用</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">tuple(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一个元组</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">binary(X)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>是一段二进制数据</td>
</tr>
</tbody>
</table>
<p>另外，一些BIF和算术表达式的组合也可以作为保护式。它们是：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nb">element</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">float</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">hd</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">length</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">round</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="nb">size</span><span class="o">/</span><span class="mi">1</span>
<span class="nb">trunc</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>   <span class="nb">tl</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">abs</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">node</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span> <span class="nb">node</span><span class="o">/</span><span class="mi">0</span><span class="p">,</span> <span class="nb">nodes</span><span class="o">/</span><span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>项式比较<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>可以出现在保护式中的项式比较运算符如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="40%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">运算符</th>
<th class="head">描述</th>
<th class="head">类型</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">&gt;</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>大于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>小于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">=&lt;</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>小于或等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">&gt;=</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>大于或等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">==</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">/=</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>不等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>coerce</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">=:=</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>exact</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">=/=</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>不等于<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>exact</td>
</tr>
</tbody>
</table>
<p>比较运算符工作机制如下：首先对运算符两边求值（如，在表达式两边存在算术表达式或包含BIF保护式函数时）；然后再进行比较。</p>
<p>为了进行比较，定义如下的偏序关系：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="n">number</span> <span class="o">&lt;</span> <span class="n">atom</span> <span class="o">&lt;</span> <span class="n">reference</span> <span class="o">&lt;</span> <span class="n">port</span> <span class="o">&lt;</span> <span class="n">pid</span> <span class="o">&lt;</span> <span class="n">tuple</span> <span class="o">&lt;</span> <span class="n">list</span>
</pre></div>
</div>
<p>元组首先按大小排序，然后再按元素排序。列表的比较顺序是先头部，后尾部。</p>
<p>如果比较运算符的两个参数都是数值类型且运算符为<em>coerce</em>型，则如果一个参数是<tt class="docutils literal"><span class="pre">integer</span></tt>另一个是<tt class="docutils literal"><span class="pre">float</span></tt>，那么<tt class="docutils literal"><span class="pre">integer</span></tt>将被转换为<tt class="docutils literal"><span class="pre">float</span></tt>再进行比较。</p>
<p><tt class="docutils literal"><span class="pre">exact</span></tt>类型的运算符则不做这样的转换。</p>
<p>因此<tt class="docutils literal"><span class="pre">5.0</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">4</span></tt>为真，而<tt class="docutils literal"><span class="pre">5.0</span> <span class="pre">=:=</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">1</span></tt>为假。</p>
<p>保护函数子句示例：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">foo</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="k">when</span> <span class="n">integer</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="n">integer</span><span class="p">(</span><span class="nv">Y</span><span class="p">),</span> <span class="n">integer</span><span class="p">(</span><span class="nv">Z</span><span class="p">),</span> <span class="nv">X</span> <span class="o">==</span> <span class="nv">Y</span> <span class="o">+</span> <span class="nv">Z</span> <span class="o">-&gt;</span>
<span class="nf">foo</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="k">when</span> <span class="n">list</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nb">hd</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="nv">Y</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="nv">Z</span><span class="p">)}</span>  <span class="o">-&gt;</span>
<span class="nf">foo</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nv">Z</span><span class="p">)</span> <span class="k">when</span> <span class="p">{</span><span class="nv">X</span><span class="p">,</span> <span class="nv">Y</span><span class="p">,</span> <span class="nb">size</span><span class="p">(</span><span class="nv">Z</span><span class="p">)}</span> <span class="o">==</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">X</span><span class="p">}</span> <span class="o">-&gt;</span>
<span class="nf">foo</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">when</span> <span class="n">list</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nb">hd</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">==</span> <span class="n">c1</span><span class="p">,</span> <span class="nb">hd</span><span class="p">(</span><span class="nb">tl</span><span class="p">(</span><span class="nv">X</span><span class="p">))</span> <span class="o">==</span> <span class="n">c2</span> <span class="o">-&gt;</span>
</pre></div>
</div>
<p>注意在保护式中不可引入新的变量。</p>
</div>
<div class="section" id="id28">
<h3>子句主体<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<p>子句的主体有一个或多个有逗号分隔的表达式序列组成。序列中的表达式依次被求值。表达式序列的值被定义为序列中<strong>最后一个</strong>表达式的值。例如，<tt class="docutils literal"><span class="pre">factorial</span></tt>的第二个子句可以写成：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span>
    <span class="nv">N1</span> <span class="o">=</span> <span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nv">F1</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N1</span><span class="p">),</span>
    <span class="nv">N</span> <span class="o">*</span> <span class="nv">F1</span><span class="p">.</span>
</pre></div>
</div>
<p>在对序列求值的过程中，表达式的求值结果要么与一个模式进行匹配，要么被直接丢弃。将函数主体拆分为序列的原因有这么几条：</p>
<ul class="simple">
<li>确保代码的顺序执行——函数主体中的表达式是依次求值的，而在嵌套的函数调用中的函数则可能以任意顺序执行。</li>
<li>增强代码可读性——将函数写成表达式序列可以令程序更清晰。</li>
<li>（通过模式匹配）拆解函数的返回值。</li>
<li>重用函数调用的返回值。</li>
</ul>
<p>对函数返回值的多次重用的示例如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">good</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="nv">Temp</span> <span class="o">=</span> <span class="n">lic</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
        <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="nv">Temp</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="nv">Temp</span><span class="p">)}.</span>
</pre></div>
</div>
<p>上面的写法比下面这么写要好：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">bad</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="p">{</span><span class="n">cos</span><span class="p">(</span><span class="n">lic</span><span class="p">(</span><span class="nv">X</span><span class="p">)),</span> <span class="n">sin</span><span class="p">(</span><span class="n">lic</span><span class="p">(</span><span class="nv">X</span><span class="p">)}.</span>
</pre></div>
</div>
<p>二者表达的是同一个含义。<tt class="docutils literal"><span class="pre">lic</span></tt>代表长而复杂的计算过程（Long and Involved Calculation），即那些计算代价高的函数。</p>
</div>
</div>
<div class="section" id="id29">
<h2>原语<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<p>Erlang提供了元语<tt class="docutils literal"><span class="pre">case</span></tt>和<tt class="docutils literal"><span class="pre">if</span></tt>，这样在子句中无需借助其他函数便可以直接进行条件求值。</p>
<div class="section" id="case">
<h3>Case<a class="headerlink" href="#case" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">case</span></tt>表达式允许在子句主体内部于多个选项中进行选择，语法如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">case</span> <span class="nv">Expr</span> <span class="k">of</span>
    <span class="nv">Pattern1</span> <span class="p">[</span><span class="k">when</span> <span class="nv">Guard1</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Seq1</span><span class="p">;</span>
    <span class="nv">Pattern2</span> <span class="p">[</span><span class="k">when</span> <span class="nv">Guard2</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">Seq2</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="nv">PatternN</span> <span class="p">[</span><span class="k">when</span> <span class="nv">GuardN</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="nv">SeqN</span>
<span class="k">end</span>
</pre></div>
</div>
<p>首先，对<tt class="docutils literal"><span class="pre">Expr</span></tt>求值，然后，<tt class="docutils literal"><span class="pre">Expr</span></tt>的值将依次与模式<tt class="docutils literal"><span class="pre">Pattern1</span></tt>、<tt class="docutils literal"><span class="pre">Pattern2</span></tt>……<tt class="docutils literal"><span class="pre">PatternN</span></tt>进行匹配，直到匹配成功。如果找到一个匹配并且（可选的）的保护式成立，则对应的调用序列将被求值。注意<tt class="docutils literal"><span class="pre">case</span></tt>保护式与函数保护式形式相同。<tt class="docutils literal"><span class="pre">case</span></tt>原语的值就是被选中的序列的值。</p>
<p>至少得有一个模式<strong>必须</strong>得以匹配——否则就会产生一个运行时错误并引发第??章中的错误处理机制。</p>
<p>举个例子，比方说我们我有个函数<tt class="docutils literal"><span class="pre">allocate(Resource)</span></tt>用于分配某种资源<tt class="docutils literal"><span class="pre">Resource</span></tt>。假设这个函数只返回<tt class="docutils literal"><span class="pre">{yes,</span> <span class="pre">Address}</span></tt>或<tt class="docutils literal"><span class="pre">no</span></tt>。这样，这个函数便可以放在一个<tt class="docutils literal"><span class="pre">case</span></tt>结构里：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">...</span>
<span class="k">case</span> <span class="n">allocate</span><span class="p">(</span><span class="nv">Resource</span><span class="p">)</span> <span class="k">of</span>
    <span class="p">{</span><span class="n">yes</span><span class="p">,</span><span class="nv">Address</span><span class="p">}</span> <span class="k">when</span> <span class="nv">Address</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="nv">Address</span> <span class="o">=&lt;</span> <span class="nv">Max</span> <span class="o">-&gt;</span>
        <span class="nv">Sequence</span> <span class="mi">1</span> <span class="p">...</span> <span class="p">;</span>
    <span class="n">no</span> <span class="o">-&gt;</span>
        <span class="nv">Sequence</span> <span class="mi">2</span> <span class="p">...</span>
<span class="k">end</span>
<span class="p">...</span>
</pre></div>
</div>
<p>在<tt class="docutils literal"><span class="pre">Sequence</span> <span class="pre">1</span> <span class="pre">...</span></tt>中，变量<tt class="docutils literal"><span class="pre">Address</span></tt>已经被绑定在了<tt class="docutils literal"><span class="pre">allocate/1</span></tt>的返回结果上。</p>
<p>为了避免匹配错误的发生，我们常常追加一个必会匹配的模式<a class="footnote-reference" href="#id40" id="id30">[6]</a>作为<tt class="docutils literal"><span class="pre">case</span></tt>原语的最后一个分支：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">case</span> <span class="nv">Fn</span> <span class="k">of</span>
    <span class="p">...</span>
    <span class="p">_</span> <span class="o">-&gt;</span>
        <span class="n">true</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="if">
<h3>If<a class="headerlink" href="#if" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">if</span></tt>表达式的语法如下：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">if</span>
    <span class="nv">Guard1</span> <span class="o">-&gt;</span>
        <span class="nv">Sequence1</span> <span class="p">;</span>
    <span class="nv">Guard2</span> <span class="o">-&gt;</span>
        <span class="nv">Sequence2</span> <span class="p">;</span>
    <span class="p">...</span>
<span class="k">end</span>
</pre></div>
</div>
<p>在这种情况下，保护式<tt class="docutils literal"><span class="pre">Guard1,...</span></tt>将被依次求值。如果一个保护式成立则对与之关联的序列求值。该序列的求值结果便是<tt class="docutils literal"><span class="pre">if</span></tt>结构的结果。<tt class="docutils literal"><span class="pre">if</span></tt>保护式与函数保护式形式相同。与<tt class="docutils literal"><span class="pre">case</span></tt>相同，一个保护式都不成立的话将引发一个错误。如果需要，可以增加保护式断言<tt class="docutils literal"><span class="pre">true</span></tt>作为垃圾箱：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="k">if</span>
    <span class="p">...</span>
    <span class="n">true</span> <span class="o">-&gt;</span>
        <span class="n">true</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="case-if">
<h3>Case 和 if 使用示例<a class="headerlink" href="#case-if" title="永久链接至标题">¶</a></h3>
<p>使用<tt class="docutils literal"><span class="pre">case</span></tt>和<tt class="docutils literal"><span class="pre">if</span></tt>我们可以以多种方式来编写<tt class="docutils literal"><span class="pre">factorial</span></tt>。</p>
<p>最简单的：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>使用函数保护式：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span>
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">if</span></tt>：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">if</span>
        <span class="nv">N</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
<p>使用<tt class="docutils literal"><span class="pre">case</span></tt>：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="nv">N</span> <span class="k">of</span>
        <span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nv">N</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span>
            <span class="nv">N</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span>
</pre></div>
</div>
<p>使用变量保持临时结果：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="mi">1</span><span class="p">;</span>
<span class="nf">factorial</span><span class="p">(</span><span class="nv">N</span><span class="p">)</span> <span class="k">when</span> <span class="nv">N</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">-&gt;</span>
    <span class="nv">N1</span> <span class="o">=</span> <span class="nv">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nv">F1</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="nv">N1</span><span class="p">),</span>
    <span class="nv">N</span> <span class="o">*</span> <span class="nv">F1</span><span class="p">.</span>
</pre></div>
</div>
<p>以上所有定义都是正确且等价的<a class="footnote-reference" href="#id41" id="id31">[7]</a>——如何进行选择完全是个美学问题<a class="footnote-reference" href="#id42" id="id32">[8]</a>。</p>
</div>
</div>
<div class="section" id="id33">
<h2>算术表达式<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h2>
<p>算术表达式由以下运算符构成：</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="50%" />
<col width="10%" />
<col width="15%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">运算符</th>
<th class="head">描述</th>
<th class="head">类型</th>
<th class="head">操作数类型</th>
<th class="head">优先级</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">+</span> <span class="pre">X</span></tt></td>
<td><tt class="docutils literal"><span class="pre">+</span> <span class="pre">X</span></tt></td>
<td>单目</td>
<td>混合</td>
<td>1</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">-</span> <span class="pre">X</span></tt></td>
<td><tt class="docutils literal"><span class="pre">-</span> <span class="pre">X</span></tt></td>
<td>单目</td>
<td>混合</td>
<td>1</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">Y</span></tt></td>
<td>双目</td>
<td>混合</td>
<td>2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">/</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">/</span> <span class="pre">Y</span></tt>（浮点除法）</td>
<td>双目</td>
<td>混合</td>
<td>2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">div</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>整除<tt class="docutils literal"><span class="pre">Y</span></tt></td>
<td>双目</td>
<td>整数</td>
<td>2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">rem</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>除以<tt class="docutils literal"><span class="pre">Y</span></tt>的余数</td>
<td>双目</td>
<td>整数</td>
<td>2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">band</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>与<tt class="docutils literal"><span class="pre">Y</span></tt>的位与</td>
<td>双目</td>
<td>整数</td>
<td>2</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">+</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">+</span> <span class="pre">Y</span></tt></td>
<td>双目</td>
<td>混合</td>
<td>3</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">-</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">-</span> <span class="pre">Y</span></tt></td>
<td>双目</td>
<td>混合</td>
<td>3</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">bor</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>与<tt class="docutils literal"><span class="pre">Y</span></tt>位或</td>
<td>双目</td>
<td>整数</td>
<td>3</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">bxor</span> <span class="pre">Y</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>与<tt class="docutils literal"><span class="pre">Y</span></tt>的位算数异或</td>
<td>双目</td>
<td>整数</td>
<td>3</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">bsl</span> <span class="pre">N</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>算数左移<tt class="docutils literal"><span class="pre">N</span></tt>位</td>
<td>双目</td>
<td>整数</td>
<td>3</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">X</span> <span class="pre">bsr</span> <span class="pre">N</span></tt></td>
<td><tt class="docutils literal"><span class="pre">X</span></tt>右移<tt class="docutils literal"><span class="pre">N</span></tt>位</td>
<td>双目</td>
<td>整数</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><strong>单目</strong>运算符有一个参数，<strong>双目</strong>运算符有两个参数。<strong>混合</strong>意味着参数即可以是<tt class="docutils literal"><span class="pre">integer</span></tt> 也可以是<tt class="docutils literal"><span class="pre">float</span></tt>。单目运算符的返回值与其参数类型相同。</p>
<p>双目混合运算符（即<tt class="docutils literal"><span class="pre">*</span></tt>、<tt class="docutils literal"><span class="pre">-</span></tt>、<tt class="docutils literal"><span class="pre">+</span></tt>）在参数都是<tt class="docutils literal"><span class="pre">integer</span></tt>时返回类型为<tt class="docutils literal"><span class="pre">integer</span></tt>的对象，在参数至少包含一个<tt class="docutils literal"><span class="pre">float</span></tt>时返回一个<tt class="docutils literal"><span class="pre">float</span></tt>。浮点除法运算符<tt class="docutils literal"><span class="pre">/</span></tt>总是返回一个<tt class="docutils literal"><span class="pre">float</span></tt>。</p>
<p>双目整数运算符（即<tt class="docutils literal"><span class="pre">band</span></tt>、<tt class="docutils literal"><span class="pre">div</span></tt>、<tt class="docutils literal"><span class="pre">rem</span></tt>、<tt class="docutils literal"><span class="pre">bor</span></tt>、<tt class="docutils literal"><span class="pre">bxor</span></tt>、<tt class="docutils literal"><span class="pre">bsl</span></tt>、<tt class="docutils literal"><span class="pre">bsr</span></tt>）的参数必须是整数，其返回值也是整数。</p>
<p>求值顺序取决于运算符的优先级：首先计算第1优先级的运算符，然后是第2优先级，以此类推。括号内的表达式优先求值。</p>
<p>优先级相同的运算符从左到右进行求值。比如：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">A</span> <span class="o">-</span> <span class="nv">B</span> <span class="o">-</span> <span class="nv">C</span> <span class="o">-</span> <span class="nv">D</span>
</pre></div>
</div>
<p>其求值顺序与下面的表达式一致：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(((</span><span class="nv">A</span> <span class="o">-</span> <span class="nv">B</span><span class="p">)</span> <span class="o">-</span> <span class="nv">C</span><span class="p">)</span> <span class="o">-</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h2>变量作用域<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<p>子句中变量的生存期从它首次被绑定处开始，到子句中对该变量的最后一个引用处结束。变量的绑定只会在模式匹配中发生；可以将之认作是一个变量产生过程。后续对变量的所有引用都是对变量的值的<strong>使用</strong>。<strong>表达式中的变量必须是经过绑定的</strong>。变量第一次出现时就被用在表达式中是非法的。比如：</p>
<div class="highlight-erlang"><table class="highlighttable"><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="highlight"><pre><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nv">Y</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span>
    <span class="n">h</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">X</span><span class="p">),</span>
    <span class="n">p</span><span class="p">(</span><span class="nv">Y</span><span class="p">).</span>
</pre></div>
</td></tr></table></div>
<p>第1行中，定义了变量<tt class="docutils literal"><span class="pre">X</span></tt>（它在进入函数时被绑定）。第2行中，使用了<tt class="docutils literal"><span class="pre">X</span></tt>，定义了<tt class="docutils literal"><span class="pre">Y</span></tt>（首次出现）。第3行中，使用了<tt class="docutils literal"><span class="pre">X</span></tt>和<tt class="docutils literal"><span class="pre">Y</span></tt>，然后在第4行中使用了<tt class="docutils literal"><span class="pre">Y</span></tt>。</p>
<div class="section" id="if-case-receive">
<h3><tt class="docutils literal"><span class="pre">if</span></tt>、<tt class="docutils literal"><span class="pre">case</span></tt>和<tt class="docutils literal"><span class="pre">receive</span></tt>的作用域规则<a class="headerlink" href="#if-case-receive" title="永久链接至标题">¶</a></h3>
<p>在<tt class="docutils literal"><span class="pre">if</span></tt>、<tt class="docutils literal"><span class="pre">case</span></tt>或<tt class="docutils literal"><span class="pre">receive</span></tt>原语中引入的变量会被隐式导出到原语主体之外。比方我们有：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">A</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="nv">X</span><span class="p">);</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="nv">A</span> <span class="o">=</span> <span class="n">k</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span>
<span class="k">end</span><span class="p">,</span>
<span class="p">...</span>
</pre></div>
</div>
<p>变量<tt class="docutils literal"><span class="pre">A</span></tt>在其被定义的<tt class="docutils literal"><span class="pre">case</span></tt>原语之后仍然有效。从<tt class="docutils literal"><span class="pre">if</span></tt>、<tt class="docutils literal"><span class="pre">case</span></tt>或<tt class="docutils literal"><span class="pre">receive</span></tt>原语中导出变量时应注意一些规则：</p>
<p><strong>在</strong><tt class="docutils literal"><span class="pre">if</span></tt><strong>、</strong><tt class="docutils literal"><span class="pre">case</span></tt><strong>或</strong><tt class="docutils literal"><span class="pre">receive</span></tt><strong>原语的不同分支中引入的变量集合必须相同，除非缺少的变量在原语外不再被引用。</strong></p>
<p>例如以下代码：</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">f</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">case</span> <span class="n">g</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="k">of</span>
        <span class="n">true</span> <span class="o">-&gt;</span> <span class="nv">A</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="nv">X</span><span class="p">),</span> <span class="nv">B</span> <span class="o">=</span> <span class="nv">A</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
        <span class="n">false</span> <span class="o">-&gt;</span> <span class="nv">B</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="k">end</span><span class="p">,</span>
<span class="nf">h</span><span class="p">(</span><span class="nv">A</span><span class="p">).</span>
</pre></div>
</div>
<p>这段代码就是非法的。因为在对<tt class="docutils literal"><span class="pre">true</span></tt>分支求值时定义了变量<tt class="docutils literal"><span class="pre">A</span></tt>和<tt class="docutils literal"><span class="pre">B</span></tt>，而在对<tt class="docutils literal"><span class="pre">false</span></tt>分支求值时只定义了<tt class="docutils literal"><span class="pre">B</span></tt>。在<tt class="docutils literal"><span class="pre">case</span></tt>原语之后，又在调用<tt class="docutils literal"><span class="pre">h(A)</span></tt>中引用了<tt class="docutils literal"><span class="pre">A</span></tt>——如果是<tt class="docutils literal"><span class="pre">fase</span></tt>分支被求值，则<tt class="docutils literal"><span class="pre">A</span></tt>尚未被定义。注意如果调用的不是<tt class="docutils literal"><span class="pre">h(A)</span></tt>而是<tt class="docutils literal"><span class="pre">h(B)</span></tt>则这段代码就是合法的，因为<tt class="docutils literal"><span class="pre">B</span></tt>在<tt class="docutils literal"><span class="pre">case</span></tt>原语的两个分支中都有定义。</p>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>附录A给出了Erlang的形式语法。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[2]</a></td><td>许多人认为破坏性赋值会导致难以理解和易错的不清晰的程序。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[3]</a></td><td>标记<tt class="docutils literal"><span class="pre">Var</span></tt>→<tt class="docutils literal"><span class="pre">Value</span></tt>表示变量<tt class="docutils literal"><span class="pre">Var</span></tt>的值为<tt class="docutils literal"><span class="pre">Value</span></tt>。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[4]</a></td><td>假设所有函数调用都结束。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[5]</a></td><td>即是说函数的<strong>值</strong>与调用上下文无关。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id30">[6]</a></td><td>有时被称为垃圾箱。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[7]</a></td><td>好吧，<strong>几乎是</strong>——想想看<tt class="docutils literal"><span class="pre">factorial(-1)</span></tt>？</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[8]</a></td><td>如果不知道选哪个，选最漂亮的那个！</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[*]</a></td><td>译者注：<tt class="docutils literal"><span class="pre">list/1</span></tt>在较新版本的Erlang中已经不推荐使用，应使用<tt class="docutils literal"><span class="pre">is_list/1</span></tt>。感谢网友<a class="reference external" href="mailto:knuth&#46;fan&#37;&#52;&#48;qq&#46;com">孔雀翎</a>指出。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">第2章 串行编程</a><ul>
<li><a class="reference internal" href="#id2">项式</a><ul>
<li><a class="reference internal" href="#id4">数值</a></li>
<li><a class="reference internal" href="#id5">原子式</a></li>
<li><a class="reference internal" href="#id6">元组</a></li>
<li><a class="reference internal" href="#id7">列表</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">模式匹配</a><ul>
<li><a class="reference internal" href="#pattern-expression"><tt class="docutils literal"><span class="pre">Pattern</span> <span class="pre">=</span> <span class="pre">Expression</span></tt></a></li>
<li><a class="reference internal" href="#id11">函数调用中的模式匹配</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id12">表达式求值</a><ul>
<li><a class="reference internal" href="#id13">函数求值</a></li>
<li><a class="reference internal" href="#id14">求值顺序</a></li>
<li><a class="reference internal" href="#id17">应用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">模块系统</a><ul>
<li><a class="reference internal" href="#id19">模块间调用</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id20">函数定义</a><ul>
<li><a class="reference internal" href="#id21">术语</a></li>
<li><a class="reference internal" href="#id23">子句</a></li>
<li><a class="reference internal" href="#id24">子句头部</a></li>
<li><a class="reference internal" href="#id25">子句保护式</a></li>
<li><a class="reference internal" href="#id26">保护式断言</a></li>
<li><a class="reference internal" href="#id27">项式比较</a></li>
<li><a class="reference internal" href="#id28">子句主体</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id29">原语</a><ul>
<li><a class="reference internal" href="#case">Case</a></li>
<li><a class="reference internal" href="#if">If</a></li>
<li><a class="reference internal" href="#case-if">Case 和 if 使用示例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33">算术表达式</a></li>
<li><a class="reference internal" href="#id34">变量作用域</a><ul>
<li><a class="reference internal" href="#if-case-receive"><tt class="docutils literal"><span class="pre">if</span></tt>、<tt class="docutils literal"><span class="pre">case</span></tt>和<tt class="docutils literal"><span class="pre">receive</span></tt>的作用域规则</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="part-i_chapter-1.html"
                        title="上一章">第1章 Erlang教程</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="part-i_chapter-3.html"
                        title="下一章">第3章 列表编程</a></p>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="part-i_chapter-3.html" title="第3章 列表编程"
             >下一页</a></li>
        <li class="right" >
          <a href="part-i_chapter-1.html" title="第1章 Erlang教程"
             >上一页</a> |</li>
        <li><a href="index.html">Erlang并发编程</a> &raquo;</li>
          <li><a href="part-i_index.html" >第 I 部分 编程</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2009, CPiE-CN志愿译者团队.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>